<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo基本知识</title>
    <url>/2021/03/30/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h1><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p>
<span id="more"></span>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p>
<p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p>
<h1 id="多个tag"><a href="#多个tag" class="headerlink" title="多个tag"></a>多个tag</h1><p><code>tags: [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]</code></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch2 变量与基本内置类型</title>
    <url>/2021/03/30/c++/cpp_ch2_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p><code>bool, char, wchar_t, char16_t, char32_t, short, int, long,  long long, float, double, long double</code></p>
<span id="more"></span>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><strong>①整型字面值</strong><br>十进制 <code>20</code>     八进制  <code>020</code>    十六进制<code>0x20 0X20</code><br>十进制字面值的默认类型是<code>int long longlong</code>中能容纳的，且位数最少的，比如2为<code>int</code>，2^17为<code>long</code><br><strong>②浮点数字面值</strong>：默认为<code>double</code><br><strong>③字符字面值</strong>：默认为<code>char</code>，如<code>&#39;a&#39;</code>；字符串为<code>char</code>的数组，如<code>&quot;ab&quot;</code><br><strong>④布尔字面值</strong>：<code>true</code>和<code>false</code><br><strong>⑤指针字面值</strong>：<code>nullptr</code><br><strong>⑥转义序列：</strong></p>
<table>
<thead>
<tr>
<th>column0</th>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>换行符：<code>\n</code></td>
<td>横向制表符：<code>\t</code></td>
<td>纵向制表符：<code>\v</code></td>
</tr>
<tr>
<td>退格符：<code>\b</code></td>
<td>回车符：<code>\r</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>用法</strong>：<code>std::cout&lt;&lt;&quot;Hello!&quot;&lt;&lt;&#39;\n&#39;;</code><br><strong>通过添加前缀，后缀可以指定（改变）字面值的类型</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><font color=#FF0000>初始化与赋值不同，初始化是创建变量时给定一个值，赋值是消去原有值并给定新值</font></p>
<h2 id="列表初始化（C-11新特性）"><a href="#列表初始化（C-11新特性）" class="headerlink" title="列表初始化（C++11新特性）"></a>列表初始化（C++11新特性）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下都是正确的</span></span><br><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>对内置类型变量用列表初始化时，<strong>如果存在丢失数据的可能，则编译器报错</strong>，比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="number">1</span>d = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// 错误:转换未执行，因为存在丢失信息的危险</span></span><br><span class="line">int c(ld)， d = ld;  //正确:转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>①对于<strong>内置基本类型</strong>：函数体外默认为0，函数体内不作初始化（访问或拷贝将出错）<br>②<strong>自定义类</strong>的默认初始化行为自定义（如<code>string</code>默认初始化为空串）<br>例子：<code>double a=b=3.14   //b未定义，若b已定义，则最终a=b</code><br><font color=#FF0000>使用未初始化变量可能造成程序错误，甚至时对时错，因而最好初始化每个变量</font></p>
<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><p>当一个程序要使用其他地方（.h）的名字时，要进行声明（比如用某个头文件里的变量名字a）。<br><strong>声明与定义的差异</strong>：<br>（1）变量在所有相关文件中只能定义一次，可以声明无数次（某个程序要用到其他地方的变量则需要声明）；<br>（2）声明规定了变量的类型和名字，而定义还额外申请存储空间，给定一个初始值<br><strong>关键字</strong><code>extern</code>：<br><code>extern int a; //只声明不定义</code><br>若写成<code>extern int a=10</code>，则<code>extern</code>失效<br><font color=#FF0000>函数体内初始化一个extern标记的变量会出错</font></p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>最好在使用变量的时候定义它<br>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明:函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; <span class="comment">// reused 拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">// unique 拥有块作用域</span></span><br><span class="line"><span class="comment">//输出#1:使用全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量reused,覆盖了全局变量reused</span></span><br><span class="line"><span class="comment">//输出#2:使用局部变量reused;输出0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//输出#3:显式地访问全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 复合类型</span><br><span class="line">## 引用</span><br><span class="line">引用(reference)为对象起了另外-一个名字，引用类型引用(refers to)另外一种类型。</span><br><span class="line">通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int &amp;refVal &#x3D; ival;  &#x2F;&#x2F; refVal指向ival (是ival的另一个名字)</span><br><span class="line">int &amp;refVal2;  &#x2F;&#x2F;报错:引用必须被初始化</span><br></pre></td></tr></table></figure>
<p>• 引用必须初始化；引用无法重新绑定到另外一个对象<br>• 引用不是对象，不能定义引用的引用，不允许拷贝<br>• 引用不能绑定字面值，只能绑定对象<br>• 给引用赋值，就是给对应变量赋值</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol>
<li>区别于引用，指针是个对象，可以重新指向其他对象，不一定要初始化，允许拷贝<br>v指针初始化时，=右边必须是地址（&amp;a），不能是变量，也不能是整型（0除外，此时为空指针）</li>
<li><strong>指针初始化</strong>:<code> int *p=&amp;a</code>    ** 指针赋值**：<code>p=&amp;a   //指针p现在指向a    </code><br><code>*p=b   //指针p指向的对象的值改为b</code></li>
<li>获取对象地址:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;</span><br><span class="line"><span class="comment">//P存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure></li>
<li> 访问指针所指对象：<code>*p</code>，<strong>解引用操作只适合确实有指向对象的指针</strong></li>
<li>注意：不能把某类型的值直接赋给对应指针</li>
</ol>
<h2 id="复合类型声明"><a href="#复合类型声明" class="headerlink" title="复合类型声明"></a>复合类型声明</h2><p>基本类型只有一个，声明符形式多样（*，&amp;是类型修饰符，是声明符的一部分）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i是一个int型的数，p是一个int型指针，r是一个int型引用</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>注意r的类型，对于复杂类型，从右往左读，离得最近的符号（&amp;）起最重要的作用<br><font color=#FF0000>*和&amp;只从属于某个声明符，不属于某个类型</font></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>关键字const把变量定义成一个常量，之后不允许修改，并且必须初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_ <span class="built_in">size</span>(); <span class="comment">// 正确:运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>; <span class="comment">//正确:编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;  <span class="comment">//错误:k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>const仅在单一文件内有效，如果想要一个常量在所有文件内有效，则使用extern声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_ 1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span>() ;</span><br><span class="line"><span class="comment">// file_ 1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize; <span class="comment">// 与file_ 1.cc 中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<h2 id="对常量的引用"><a href="#对常量的引用" class="headerlink" title="对常量的引用"></a>对常量的引用</h2><p>显然不能修改引用指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确:引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">// 错误: r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误:试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<p>常量只能被常量引用指向，而初始化常量引用不一定要用常量，<strong>允许常量引用绑定非常量、字面值、表达式</strong>，但是不允许用该常量引用修改绑定对象</p>
<h2 id="指向常量的指针和常量指针"><a href="#指向常量的指针和常量指针" class="headerlink" title="指向常量的指针和常量指针"></a>指向常量的指针和常量指针</h2><p>A) 对常量的指针，也不能修改指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">//错误: ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确: cptr可以指向一个双精度常量</span></span><br></pre></td></tr></table></figure>
<p>B) 常量指针：指针本身是常量，必须初始化，其指（保存的地址）不能改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr 将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<p>判断类型：从右往左<br>常量指针不意味着不能通过指针修改绑定对象（取决于对象的类型）</p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const表示指针本身是个常量，底层const表示指针指向常量<br>一般地，顶层const可以指所有自身是常量的对象，底层const与引用或指针相关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>
<p>两者的区别在于拷贝操作，其中顶层const没有影响；对于底层const，拷入和拷出的对象必须具有相同的底层const资格，或者能相互转换（非常量能变成常量，反之不行）</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式是值不会改变，且在编译过程中就能获得的值（区别于运行阶段）<br>字面值和用常量表达式初始化的常量都是常量表达式，即判定常量表达式只要考察类型和初始值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_ files = <span class="number">20</span>; <span class="comment">// max_ files是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_ files + <span class="number">1</span>; <span class="comment">// limit 是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_ size = <span class="number">27</span>; <span class="comment">// staff_ size不是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_ <span class="built_in">size</span>(); <span class="comment">// sz 不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>【注意，第四个表达式在运行阶段（不是编译阶段）获得值】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constexpr int mf &#x3D; 20; &#x2F;&#x2F; 20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1; &#x2F;&#x2F; mf + 1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size() ; &#x2F;&#x2F;只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<p>A)可以用<code>constexpr</code>函数（该函数简单到在编译时就能获得结果）来初始化<code>constexpr</code>变量<br>B)<code>constexpr</code>的指针初始值必须为<code>nullptr/0</code>，或是某个固定地址的对象（函数体内变量一般不固定地址，不能定义为<code>constexpr</code>，函数体外则可以）<br>C)<code>constexpr</code>定义的指针表示指针是个常量指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在<br>于<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code> ,从而<code>constexpr</code>指针既可以指向常量，也可以指向非常量</p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;</span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure>
<p><strong>复合类型的别名可能造成错误</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps指向一个指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>; <span class="comment">//对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure>
<h2 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h2><p>让编译器自动推断类型，变量必须被初始化<br>auto能在一个语句里定义多个变量，但是每个变量类型必须相同<br>对于复合类型：<br>1）引用：推断的类型取决于引用的对象<br><code>int i=0,&amp;r=I;  auto b=r;  //b是int</code><br>2）auto会忽略顶层const，保留底层const；若要明确指出顶层const，则需要在auto前加const</p>
<h2 id="关键字decltype"><a href="#关键字decltype" class="headerlink" title="关键字decltype"></a>关键字decltype</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum的 类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure>
<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量,则<code>decltype</code>返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>，&amp;Cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int&amp;, y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">//错误:z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>因为cj是一个引用，<code>decltype (cj)</code>的结果就是引用类型，因此作为引用的z必须被初始化。<br>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在<code>decltype</code>处是一个例外。</p>
<p><strong>decltype和引用</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype 的结果可以是引用类型</span></span><br><span class="line">inti=<span class="number">42</span>，*p=&amp;i，&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// 正确:加法的结果是int，因此b是一个(未初始化的) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) C; <span class="comment">//错误:c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>r+0的结果是个int；解引操作*p得到的是引用类型<br>此外，如果给变量套一个括号，编译器会认为这是个变量；套多层括号则会认为是表达式，从而返回引用类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误: d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确: e是一个(未初始化的) int</span></span><br></pre></td></tr></table></figure>
<p>赋值会产生引用类型，如果i是int，则表达式<code>i=a</code>的类型是<code>int&amp;</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>变量</tag>
        <tag>基本内置类型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch1 入门</title>
    <url>/2021/03/30/c++/cpp_ch1_%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>输入一系列数据时，可使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin&gt;&gt;value)</span><br></pre></td></tr></table></figure>
<p>当输入文件结束符时，语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cin&gt;&gt;value</span><br></pre></td></tr></table></figure>
<p>的值为0，从而退出循环<br>文件结束符：<em>windows</em>  <code>ctrl+Z</code>    <em>unix</em>  <code>ctrl+D</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
