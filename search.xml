<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo基本知识</title>
    <url>/2021/03/30/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h1><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p>
<span id="more"></span>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p>
<p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p>
<h1 id="多个tag"><a href="#多个tag" class="headerlink" title="多个tag"></a>多个tag</h1><p><code>tags: [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]</code></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch1 入门</title>
    <url>/2021/03/30/c++/cpp_ch1_%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>输入一系列数据时，可使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin&gt;&gt;value)</span><br></pre></td></tr></table></figure>
<p>当输入文件结束符时，语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cin&gt;&gt;value</span><br></pre></td></tr></table></figure>
<p>的值为0，从而退出循环<br>文件结束符：<em>windows</em>  <code>ctrl+Z</code>    <em>unix</em>  <code>ctrl+D</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch2 变量与基本内置类型</title>
    <url>/2021/03/30/c++/cpp_ch2_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p><code>bool, char, wchar_t, char16_t, char32_t, short, int, long,  long long, float, double, long double</code></p>
<span id="more"></span>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><strong>①整型字面值</strong><br>十进制 <code>20</code>     八进制  <code>020</code>    十六进制<code>0x20 0X20</code><br>十进制字面值的默认类型是<code>int long longlong</code>中能容纳的，且位数最少的，比如2为<code>int</code>，2^17为<code>long</code><br><strong>②浮点数字面值</strong>：默认为<code>double</code><br><strong>③字符字面值</strong>：默认为<code>char</code>，如<code>&#39;a&#39;</code>；字符串为<code>char</code>的数组，如<code>&quot;ab&quot;</code><br><strong>④布尔字面值</strong>：<code>true</code>和<code>false</code><br><strong>⑤指针字面值</strong>：<code>nullptr</code><br><strong>⑥转义序列：</strong></p>
<table>
<thead>
<tr>
<th>column0</th>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>换行符：<code>\n</code></td>
<td>横向制表符：<code>\t</code></td>
<td>纵向制表符：<code>\v</code></td>
</tr>
<tr>
<td>退格符：<code>\b</code></td>
<td>回车符：<code>\r</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>用法</strong>：<code>std::cout&lt;&lt;&quot;Hello!&quot;&lt;&lt;&#39;\n&#39;;</code><br><strong>通过添加前缀，后缀可以指定（改变）字面值的类型</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><font color=#FF0000>初始化与赋值不同，初始化是创建变量时给定一个值，赋值是消去原有值并给定新值</font></p>
<h2 id="列表初始化（C-11新特性）"><a href="#列表初始化（C-11新特性）" class="headerlink" title="列表初始化（C++11新特性）"></a>列表初始化（C++11新特性）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下都是正确的</span></span><br><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>对内置类型变量用列表初始化时，<strong>如果存在丢失数据的可能，则编译器报错</strong>，比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="number">1</span>d = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// 错误:转换未执行，因为存在丢失信息的危险</span></span><br><span class="line">int c(ld)， d = ld;  //正确:转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>①对于<strong>内置基本类型</strong>：函数体外默认为0，函数体内不作初始化（访问或拷贝将出错）<br>②<strong>自定义类</strong>的默认初始化行为自定义（如<code>string</code>默认初始化为空串）<br>例子：<code>double a=b=3.14   //b未定义，若b已定义，则最终a=b</code><br><font color=#FF0000>使用未初始化变量可能造成程序错误，甚至时对时错，因而最好初始化每个变量</font></p>
<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><p>当一个程序要使用其他地方（.h）的名字时，要进行声明（比如用某个头文件里的变量名字a）。<br><strong>声明与定义的差异</strong>：<br>（1）变量在所有相关文件中只能定义一次，可以声明无数次（某个程序要用到其他地方的变量则需要声明）；<br>（2）声明规定了变量的类型和名字，而定义还额外申请存储空间，给定一个初始值<br><strong>关键字</strong><code>extern</code>：<br><code>extern int a; //只声明不定义</code><br>若写成<code>extern int a=10</code>，则<code>extern</code>失效<br><font color=#FF0000>函数体内初始化一个extern标记的变量会出错</font></p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>最好在使用变量的时候定义它<br>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明:函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; <span class="comment">// reused 拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">// unique 拥有块作用域</span></span><br><span class="line"><span class="comment">//输出#1:使用全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量reused,覆盖了全局变量reused</span></span><br><span class="line"><span class="comment">//输出#2:使用局部变量reused;输出0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//输出#3:显式地访问全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 复合类型</span><br><span class="line">## 引用</span><br><span class="line">引用(reference)为对象起了另外-一个名字，引用类型引用(refers to)另外一种类型。</span><br><span class="line">通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int &amp;refVal &#x3D; ival;  &#x2F;&#x2F; refVal指向ival (是ival的另一个名字)</span><br><span class="line">int &amp;refVal2;  &#x2F;&#x2F;报错:引用必须被初始化</span><br></pre></td></tr></table></figure>
<p>• 引用必须初始化；引用无法重新绑定到另外一个对象<br>• 引用不是对象，不能定义引用的引用，不允许拷贝<br>• 引用不能绑定字面值，只能绑定对象<br>• 给引用赋值，就是给对应变量赋值</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol>
<li>区别于引用，指针是个对象，可以重新指向其他对象，不一定要初始化，允许拷贝<br>v指针初始化时，=右边必须是地址（&amp;a），不能是变量，也不能是整型（0除外，此时为空指针）</li>
<li><strong>指针初始化</strong>:<code> int *p=&amp;a</code>    ** 指针赋值**：<code>p=&amp;a   //指针p现在指向a    </code><br><code>*p=b   //指针p指向的对象的值改为b</code></li>
<li>获取对象地址:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;</span><br><span class="line"><span class="comment">//P存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure></li>
<li> 访问指针所指对象：<code>*p</code>，<strong>解引用操作只适合确实有指向对象的指针</strong></li>
<li>注意：不能把某类型的值直接赋给对应指针</li>
</ol>
<h2 id="复合类型声明"><a href="#复合类型声明" class="headerlink" title="复合类型声明"></a>复合类型声明</h2><p>基本类型只有一个，声明符形式多样（*，&amp;是类型修饰符，是声明符的一部分）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i是一个int型的数，p是一个int型指针，r是一个int型引用</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>注意r的类型，对于复杂类型，从右往左读，离得最近的符号（&amp;）起最重要的作用<br><font color=#FF0000>*和&amp;只从属于某个声明符，不属于某个类型</font></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>关键字const把变量定义成一个常量，之后不允许修改，并且必须初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_ <span class="built_in">size</span>(); <span class="comment">// 正确:运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>; <span class="comment">//正确:编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;  <span class="comment">//错误:k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>const仅在单一文件内有效，如果想要一个常量在所有文件内有效，则使用extern声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_ 1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span>() ;</span><br><span class="line"><span class="comment">// file_ 1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize; <span class="comment">// 与file_ 1.cc 中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<h2 id="对常量的引用"><a href="#对常量的引用" class="headerlink" title="对常量的引用"></a>对常量的引用</h2><p>显然不能修改引用指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确:引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">// 错误: r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误:试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<p>常量只能被常量引用指向，而初始化常量引用不一定要用常量，<strong>允许常量引用绑定非常量、字面值、表达式</strong>，但是不允许用该常量引用修改绑定对象</p>
<h2 id="指向常量的指针和常量指针"><a href="#指向常量的指针和常量指针" class="headerlink" title="指向常量的指针和常量指针"></a>指向常量的指针和常量指针</h2><p>A) 对常量的指针，也不能修改指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">//错误: ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确: cptr可以指向一个双精度常量</span></span><br></pre></td></tr></table></figure>
<p>B) 常量指针：指针本身是常量，必须初始化，其指（保存的地址）不能改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr 将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<p>判断类型：从右往左<br>常量指针不意味着不能通过指针修改绑定对象（取决于对象的类型）</p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const表示指针本身是个常量，底层const表示指针指向常量<br>一般地，顶层const可以指所有自身是常量的对象，底层const与引用或指针相关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>
<p>两者的区别在于拷贝操作，其中顶层const没有影响；对于底层const，拷入和拷出的对象必须具有相同的底层const资格，或者能相互转换（非常量能变成常量，反之不行）</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式是值不会改变，且在编译过程中就能获得的值（区别于运行阶段）<br>字面值和用常量表达式初始化的常量都是常量表达式，即判定常量表达式只要考察类型和初始值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_ files = <span class="number">20</span>; <span class="comment">// max_ files是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_ files + <span class="number">1</span>; <span class="comment">// limit 是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_ size = <span class="number">27</span>; <span class="comment">// staff_ size不是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_ <span class="built_in">size</span>(); <span class="comment">// sz 不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>【注意，第四个表达式在运行阶段（不是编译阶段）获得值】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constexpr int mf &#x3D; 20; &#x2F;&#x2F; 20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1; &#x2F;&#x2F; mf + 1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size() ; &#x2F;&#x2F;只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<p>A)可以用<code>constexpr</code>函数（该函数简单到在编译时就能获得结果）来初始化<code>constexpr</code>变量<br>B)<code>constexpr</code>的指针初始值必须为<code>nullptr/0</code>，或是某个固定地址的对象（函数体内变量一般不固定地址，不能定义为<code>constexpr</code>，函数体外则可以）<br>C)<code>constexpr</code>定义的指针表示指针是个常量指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在<br>于<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code> ,从而<code>constexpr</code>指针既可以指向常量，也可以指向非常量</p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;</span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure>
<p><strong>复合类型的别名可能造成错误</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps指向一个指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>; <span class="comment">//对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure>
<h2 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h2><p>让编译器自动推断类型，变量必须被初始化<br>auto能在一个语句里定义多个变量，但是每个变量类型必须相同<br>对于复合类型：<br>1）引用：推断的类型取决于引用的对象<br><code>int i=0,&amp;r=I;  auto b=r;  //b是int</code><br>2）auto会忽略顶层const，保留底层const；若要明确指出顶层const，则需要在auto前加const</p>
<h2 id="关键字decltype"><a href="#关键字decltype" class="headerlink" title="关键字decltype"></a>关键字decltype</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum的 类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure>
<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量,则<code>decltype</code>返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>，&amp;Cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int&amp;, y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">//错误:z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>因为cj是一个引用，<code>decltype (cj)</code>的结果就是引用类型，因此作为引用的z必须被初始化。<br>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在<code>decltype</code>处是一个例外。</p>
<p><strong>decltype和引用</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype 的结果可以是引用类型</span></span><br><span class="line">inti=<span class="number">42</span>，*p=&amp;i，&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// 正确:加法的结果是int，因此b是一个(未初始化的) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) C; <span class="comment">//错误:c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>r+0的结果是个int；解引操作*p得到的是引用类型<br>此外，如果给变量套一个括号，编译器会认为这是个变量；套多层括号则会认为是表达式，从而返回引用类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误: d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确: e是一个(未初始化的) int</span></span><br></pre></td></tr></table></figure>
<p>赋值会产生引用类型，如果i是int，则表达式<code>i=a</code>的类型是<code>int&amp;</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>变量</tag>
        <tag>基本内置类型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch12 动态内存与智能指针</title>
    <url>/2021/04/01/c++/cpp-ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>静态内存</strong>：保存局部static变量、类static变量和在函数体外定义的变量<br><strong>栈内存</strong>：保存定义在函数体内的非static变量<br>分配在静态内存和栈内存中的对象由<font color="red">编译器自动创建或销毁</font>；栈对象仅在程序块运行时存在；static在程序结束时销毁</p>
<p>此外，每个程序还拥有一个内存池（堆内存）用于<font color="red">动态分配</font>的对象；这类对象的生存周期由程序控制，即需要代码显示销毁<br> <span id="more"></span></p>
<h1 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h1><p> <strong>动态内存</strong>的管理时通过<font color="red">运算符</font><code>new</code>和<code>delete</code>完成的，<code>new</code>在对象在动态内存中分配空间并返回一个指向该对象的指针，<code>delete</code>接受一个指向动态对象的指针并销毁该对象，释放关联的内存<br> 忘记释放内存就会造成<font color="red">内存泄漏</font></p>
<p> <strong>智能指针</strong>用于安全地使用动态内存，可以自动释放所指向的对象；<code>shared_ptr</code>允许多个指针指向同一个对象、<code>unqiue_ptr</code>独占指向的对象、<code>weak_ptr</code>是一种弱引用，指向<code>shared_ptr</code>管理的对象<br> 智能指针在头文件<code>&lt;memory&gt;</code>中</p>
<h2 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h2><p>shared_ptr是一个模板类，定义时要在尖括号里给出指向对象的类型</p>
<p><strong>shared_ptr与unqiue_ptr都支持的操作</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;   <span class="comment">//默认初始化，包含一个空指针</span></span><br><span class="line">unique_ptr&lt;T&gt; up;</span><br><span class="line">p;  <span class="comment">//用作条件判断，有指向的对象就为true</span></span><br><span class="line">*p;  <span class="comment">//解引用；</span></span><br><span class="line">p-&gt;mem;  </span><br><span class="line">p.<span class="built_in">get</span>();  <span class="comment">//返回p中保存的指针</span></span><br><span class="line"><span class="built_in">swap</span>(p,q);  <span class="comment">//交换包含的指针</span></span><br><span class="line">p.<span class="built_in">swap</span>(q);</span><br></pre></td></tr></table></figure>
<p><strong>shared_ptr独有的操作</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">make_shared&lt;T&gt;(args);  <span class="comment">//返回一个动态分配的、类型为T的对象的智能指针，对象用args初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q)</span></span>;  <span class="comment">//拷贝初始化，q中的计数器会递增。q中的指针必须能转换为T*</span></span><br><span class="line">p=q;  <span class="comment">//p与q都必须是shared_ptr,且保存的指针能相互转换。</span></span><br><span class="line">      <span class="comment">//此操作会递减p的计数器并递增q的计数器，如果p的计数器为0，则释放</span></span><br><span class="line">p.<span class="built_in">unqiue</span>();  <span class="comment">//若p.use_count() == 1，则返回true，否则false</span></span><br><span class="line">p.<span class="built_in">use_count</span>(); <span class="comment">//返回与p共享对象的智能指针数量，可能很慢</span></span><br></pre></td></tr></table></figure>
<h3 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h3><p>这是分配和使用动态内存最安全的方法，注意该函数也要<strong>传入创建对象的类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//make_shared&lt;T&gt;(args)</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; int_p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">//int_p指向值为42的int</span></span><br><span class="line">shared_ptr&lt;string&gt; str_p = make_shared&lt;string&gt;(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)  <span class="comment">//str_p指向值为&quot;aaa&quot;的字符串</span></span><br></pre></td></tr></table></figure>
<p>args即指向对象类型的构造函数参数列表，不传递参数则进行<strong>值初始化</strong></p>
<p>可以用auto定义一个对象保存<code>make_shared</code>的返回值</p>
<h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象<br>每个<code>shared_ptr</code>都有一个引用计数，当1) 用一个<code>shared_ptr</code>初始化另一个 2) 作为参数传递给函数 3) 作为函数的返回值 时，计数都会<strong>递增</strong>。当某个<code>shared_ptr</code>被赋予新值或者被销毁，计数就会<strong>递减</strong></p>
<h3 id="shared-ptr的自动销毁"><a href="#shared-ptr的自动销毁" class="headerlink" title="shared_ptr的自动销毁"></a>shared_ptr的自动销毁</h3><p>当指向对象的最后一个<code>shared_ptr</code>被销毁时（引用计数为0），<code>shared_ptr</code>类就会自动销毁此对象（通过调用<strong>析构函数</strong>）</p>
<p>对于一块内存，只要有一个<code>shared_ptr</code>对象引用它，该内存就不会被释放。如果<code>shared_ptr</code>无用且未销毁，则会浪费内存。</p>
<h3 id="程序为何使用动态内存？"><a href="#程序为何使用动态内存？" class="headerlink" title="程序为何使用动态内存？"></a>程序为何使用动态内存？</h3><p>a) 程序不知道自己要使用多少对象<br>b) 程序不知道自己所需对象的准确类型<br>c) 程序需要在多个对象间共享数据</p>
<h2 id="直接管理内存（new、delete）"><a href="#直接管理内存（new、delete）" class="headerlink" title="直接管理内存（new、delete）"></a>直接管理内存（new、delete）</h2><p>区别于智能指针，<code>new</code>和<code>delete</code>不能依赖对象的拷贝、赋值和销毁的默认定义，容易出错</p>
<h3 id="使用new动态分配和初始化对象"><a href="#使用new动态分配和初始化对象" class="headerlink" title="使用new动态分配和初始化对象"></a>使用new动态分配和初始化对象</h3><p>自由空间分配的内存是无名的，因而new无法为其分配的对象命名，而是返回一个指向该对象的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认情况下，动态分配的对象是默认初始化的</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; <span class="comment">//ps指向一个空串</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//pi指向一个未初始化的int</span></span><br><span class="line"><span class="comment">//可以用直接初始化或列表初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//指向一个值为&quot;aaaaa&quot;的字符串</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; </span><br><span class="line"><span class="comment">//也可以用值初始化,即加一对空括号</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p>对于有自己的构造函数的类型来说，值初始化没有意义；但对于<strong>内置类型</strong>，值初始化对内置类型有良好定义的值，而默认初始化对象的值则是无定义的</p>
<p>截至P408</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>动态内存</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础3</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<h1 id="html-CSS"><a href="#html-CSS" class="headerlink" title="html CSS"></a>html CSS</h1><p>通过使用 HTML4.0，所有的格式化代码均可移出 HTML 文档，然后移入一个独立的样式表。</p>
<span id="more"></span>
<h2 id="如何使用样式"><a href="#如何使用样式" class="headerlink" title="如何使用样式"></a>如何使用样式</h2><p>当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。<br>有以下三种方式来插入样式表：</p>
<h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>使用外部样式表，可以通过更改一个文件来改变整个站点的外观。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。<br>可以在 head 部分通过 <code>&lt;style&gt;</code> 标签定义内部样式表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式<br>使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; margin-left: 20px&quot;</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="html表格"><a href="#html表格" class="headerlink" title="html表格"></a>html表格</h1><p>表格由 <code>&lt;table&gt;</code> 标签来定义。每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干单元格（由 <code>&lt;td&gt;</code> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示：</p>
<table border="1">
<tr>
<td>row 1, cell 1</td>
<td>row 1, cell 2</td>
</tr>
<tr>
<td>row 2, cell 1</td>
<td>row 2, cell 2</td>
</tr>
</table>

<h2 id="表格的边框属性"><a href="#表格的边框属性" class="headerlink" title="表格的边框属性"></a>表格的边框属性</h2><p>如果不定义边框属性，表格将不显示边框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="表格的表头"><a href="#表格的表头" class="headerlink" title="表格的表头"></a>表格的表头</h2><p>表格的表头使用 th标签进行定义。<br>大多数浏览器会把表头显示为粗体居中的文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="空单元格"><a href="#空单元格" class="headerlink" title="空单元格"></a>空单元格</h2><p>如果某个单元格是空的（没有内容），浏览器可能无法显示出这个单元格的边框<br>为了避免这种情况，在空单元格中添加一个<strong>空格占位符</strong>，就可以将边框显示出来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="comment">&lt;!--空格占位符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="html列表"><a href="#html列表" class="headerlink" title="html列表"></a>html列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>此列项目使用粗体圆点（典型的小黑圆圈）进行标记<br>无序列表始于 <code>&lt;ul&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>列表项目使用数字进行标记<br>有序列表始于 <code>&lt;ol&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code> 标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>自定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<dl>
<dt>Coffee</dt>
<dd>Black hot drink</dd>
<dt>Milk</dt>
<dd>White cold drink</dd>
</dl>

<h1 id="html-块"><a href="#html-块" class="headerlink" title="html 块"></a>html 块</h1><h2 id="html块元素"><a href="#html块元素" class="headerlink" title="html块元素"></a>html块元素</h2><p>块级元素在浏览器显示时，<strong>通常会以新行来开始（和结束）</strong>，例如<code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;table&gt;</code></p>
<h3 id="html-div"><a href="#html-div" class="headerlink" title="html div"></a>html div</h3><p><code>&lt;div&gt;</code> 可定义文档中的分区或节（division/section）。</p>
<p><code>&lt;div&gt;</code> 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。</p>
<p>如果用 id 或 class 来标记 <code>&lt;div&gt;</code>，那么该标签的作用会变得更加有效。</p>
<h2 id="html-内联元素"><a href="#html-内联元素" class="headerlink" title="html 内联元素"></a>html 内联元素</h2><p>内联元素在显示时通常不会以新行开始，例如<code>&lt;b&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code></p>
<h3 id="html-span"><a href="#html-span" class="headerlink" title="html span"></a>html span</h3><p>HTML <code>&lt;span&gt;</code> 元素是内联元素，可用作文本的容器。</p>
<p><code>&lt;span&gt;</code> 元素也没有特定的含义。</p>
<p>当与 CSS 一同使用时，<code>&lt;span&gt;</code> 元素可用于为部分文本设置样式属性。</p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础4</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%804/</url>
    <content><![CDATA[<h1 id="html-id属性"><a href="#html-id属性" class="headerlink" title="html id属性"></a>html id属性</h1><p>HTML id 属性用于 为HTML 元素指定唯一的 id。<br>一个 HTML文档中不能存在多个有相同 id 的元素。</p>
<span id="more"></span>
<h2 id="使用id属性"><a href="#使用id属性" class="headerlink" title="使用id属性"></a>使用id属性</h2><p>id 属性用于指向样式表中的特定样式声明。JavaScript 也可使用它来访问和操作拥有特定 ID 的元素。</p>
<p>id 的<strong>语法</strong>是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。</p>
<p>下面的例子中有一个 <code>&lt;h1&gt;</code> 元素，它指向 id 名称 “myHeader”。这个 <code>&lt;h1&gt;</code> 元素将根据 head 部分中的 #myHeader 样式定义进行样式设置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#myHeader &#123;</span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;myHeader&quot;</span>&gt;</span>My Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="与class的差异"><a href="#与class的差异" class="headerlink" title="与class的差异"></a>与class的差异</h2><p>同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用</p>
<h2 id="通过-ID-和链接实现-HTML-书签"><a href="#通过-ID-和链接实现-HTML-书签" class="headerlink" title="通过 ID 和链接实现 HTML 书签"></a>通过 ID 和链接实现 HTML 书签</h2><p>HTML 书签用于<strong>让读者跳转至网页的特定部分</strong>。</p>
<p>要使用书签，您必须首先创建它，然后为它添加链接。</p>
<p>然后，当单击链接时，页面将滚动到带有书签的位置。</p>
<p>实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//创建书签</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">//然后，在同一张页面中，向这个书签添加一个链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">//或者，在另一张页面中，添加指向这个书签的链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;html_demo.html#C4&quot;</span>&gt;</span>Jump to Chapter 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在-JavaScript-中使用-id-属性"><a href="#在-JavaScript-中使用-id-属性" class="headerlink" title="在 JavaScript 中使用 id 属性"></a>在 JavaScript 中使用 id 属性</h2><p>JavaScript 也可以使用 id 属性为特定元素执行某些任务。</p>
<p>JavaScript 可以使用 getElementById() 方法访问拥有特定 id 的元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">displayResult</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;myHeader&quot;</span>).innerHTML = <span class="string">&quot;Have a nice day!&quot;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html-内联框架"><a href="#html-内联框架" class="headerlink" title="html 内联框架"></a>html 内联框架</h1><p>iframe 用于<strong>在网页内显示网页</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> <span class="comment">&lt;!--URL 指向隔离页面的位置--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Iframe-设置高度和宽度"><a href="#Iframe-设置高度和宽度" class="headerlink" title="Iframe 设置高度和宽度"></a>Iframe 设置高度和宽度</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性值的默认单位是像素，但也可以用<strong>百分比</strong>来设定（比如 “80%”）</p>
<h2 id="Iframe-删除边框"><a href="#Iframe-删除边框" class="headerlink" title="Iframe 删除边框"></a>Iframe 删除边框</h2><p>frameborder 属性规定是否显示 iframe 周围的边框,设置属性值为 “0” 就可以移除边框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-iframe-作为链接的目标"><a href="#使用-iframe-作为链接的目标" class="headerlink" title="使用 iframe 作为链接的目标"></a>使用 iframe 作为链接的目标</h2><p>iframe 可用作链接的目标（target）。</p>
<p>链接的 target 属性必须引用 iframe 的 name 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>W3School.com.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html-javascript"><a href="#html-javascript" class="headerlink" title="html javascript"></a>html javascript</h1><p>HTML <code>&lt;script&gt;</code> 标签用于定义客户端脚本（JavaScript）。</p>
<p><code>&lt;script&gt;</code> 元素即可包含脚本语句，也可通过 src 属性指向外部脚本文件。</p>
<p>JavaScript 的常见用途是图像处理、表单验证和内容的动态更改。</p>
<p>HTML <code>&lt;noscript&gt;</code> 标签定义了替代内容，这些内容将显示给在浏览器中禁用了脚本或浏览器不支持脚本的用户</p>
<h1 id="html-文件路径"><a href="#html-文件路径" class="headerlink" title="html 文件路径"></a>html 文件路径</h1><table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;img src=&quot;picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于与当前网页相同的文件夹</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;images/picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于当前文件夹的 images 文件夹中</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;/images/picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 当前站点根目录的 images 文件夹中</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;../picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于当前文件夹的上一级文件夹中</td>
</tr>
</tbody></table>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径描述了网站文件夹结构中某个文件的位置。</p>
<p>文件路径会在链接外部文件时被用到：网页、图像、样式表、JavaScript</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>给出完整的文件路径，比如src=”<a href="https://www.w3school.com.cn/images/picture.jpg&quot;">https://www.w3school.com.cn/images/picture.jpg&quot;</a></p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>见表格</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础2</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h1><h2 id="html-文本格式化标签"><a href="#html-文本格式化标签" class="headerlink" title="html 文本格式化标签"></a>html 文本格式化标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>定义粗体文本</td>
</tr>
<tr>
<td>em</td>
<td>定义着重文字</td>
</tr>
<tr>
<td>i</td>
<td>定义斜体字</td>
</tr>
<tr>
<td>small</td>
<td>定义小号字</td>
</tr>
<tr>
<td>strong</td>
<td>定义加重语气</td>
</tr>
<tr>
<td>sub</td>
<td>定义下标字</td>
</tr>
<tr>
<td>sup</td>
<td>定义上标字</td>
</tr>
<tr>
<td>ins</td>
<td>定义插入字</td>
</tr>
<tr>
<td>del</td>
<td>定义删除字</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>通常标签 <code>&lt;strong&gt;</code> 替换加粗标签 <code>&lt;b&gt;</code> 来使用, <code>&lt;em&gt;</code> 替换 <code>&lt;i&gt;</code>标签使用。</p>
<h2 id="html-“计算机输出”-标签"><a href="#html-“计算机输出”-标签" class="headerlink" title="html “计算机输出” 标签"></a>html “计算机输出” 标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>定义计算机代码</td>
</tr>
<tr>
<td>kbd</td>
<td>定义键盘码</td>
</tr>
<tr>
<td>samp</td>
<td>定义计算机代码样本</td>
</tr>
<tr>
<td>var</td>
<td>定义变量</td>
</tr>
<tr>
<td>pre</td>
<td>定义预格式文本</td>
</tr>
</tbody></table>
<h1 id="html链接"><a href="#html链接" class="headerlink" title="html链接"></a>html链接</h1><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p>
<p>在标签<code>&lt;a&gt;</code> 中使用了href属性来描述链接的地址</p>
<h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>//格式<br><code>&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt;</code><br>//例子<br><code>&lt;a href=&quot;https://www.runoob.com/&quot;&gt;访问菜鸟教程&lt;/a&gt;</code></p>
<h2 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h2><p>使用 target 属性定义被链接的文档在何处显示</p>
<p>例子：<br><code>&lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;访问菜鸟教程!&lt;/a&gt;</code></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_blank</td>
<td>在新窗口中打开被链接文档</td>
</tr>
<tr>
<td>_self</td>
<td>默认。在相同的框架中打开被链接文档</td>
</tr>
<tr>
<td>_parent</td>
<td>在父框架集中打开被链接文档</td>
</tr>
<tr>
<td>_top</td>
<td>在整个窗口中打开被链接文档</td>
</tr>
</tbody></table>
<h2 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h2><p>id属性可用于创建在一个HTML文档书签标记</p>
<p>书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的</p>
<p>用法：<br>在HTML文档中插入ID:<br><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></p>
<p>在HTML文档中创建一个链接到  有用的提示部分(id=”tips”）：<br><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p>
<p>或者，从另一个页面创建一个链接到  有用的提示部分(id=”tips”）：<br><code>&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p>
<h1 id="html引用"><a href="#html引用" class="headerlink" title="html引用"></a>html引用</h1><p><strong>短引用</strong>：<code>&lt;q&gt;aaaaaaa&lt;/q&gt;</code><br><strong>长引用</strong>：<code>&lt;blockquote&gt;aaaaaaaaaaaaaaaaaa&lt;/blockquote&gt;</code></p>
<p><strong>缩略词</strong>：对缩写进行标记能够为浏览器、翻译系统以及搜索引擎提供有用的信息<br><code>&lt;abbr title=&quot;World Health Organization&quot;&gt;WHO&lt;/abbr&gt;</code></p>
<p><strong>地址</strong>：用于联系信息的 HTML <code>&lt;address&gt;</code>，通常以斜体显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">Written by Donald Duck.<span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">Visit us at:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Example.com<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Box 564, Disneyland<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">USA</span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>著作标题</strong>：HTML <code>&lt;cite&gt;</code> 元素定义著作的标题。浏览器通常会以斜体显示 <code>&lt;cite&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">cite</span>&gt;</span>The Scream<span class="tag">&lt;/<span class="name">cite</span>&gt;</span> by Edward Munch. Painted in 1893.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>双向重写</strong>：<code>&lt;bdo&gt;</code> 元素用于覆盖当前文本方向</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>This text will be written from right to left<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html颜色"><a href="#html颜色" class="headerlink" title="html颜色"></a>html颜色</h1><p>只有少数颜色能直接用颜色名：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow</p>
<p>其他的颜色必须用#开始的16进制串</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础5</title>
    <url>/2021/04/03/html/html-%E5%9F%BA%E7%A1%805/</url>
    <content><![CDATA[<h1 id="HTML-头部元素"><a href="#HTML-头部元素" class="headerlink" title="HTML 头部元素"></a>HTML 头部元素</h1><h2 id="HTML-lt-head-gt-元素"><a href="#HTML-lt-head-gt-元素" class="headerlink" title="HTML &lt;head&gt; 元素"></a>HTML <code>&lt;head&gt;</code> 元素</h2><p>head 元素是所有头部元素的容器。</p>
<p>以下标签都可以添加到 head 部分：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code> 以及 <code>&lt;style&gt;</code></p>
<span id="more"></span>
<h2 id="HTML-title-元素"><a href="#HTML-title-元素" class="headerlink" title="HTML title  元素"></a>HTML title  元素</h2><p>title 标签定义文档的标题。<br>title 元素能够：定义浏览器工具栏中的标题;提供页面被添加到收藏夹时显示的标题;显示在搜索引擎结果中的页面标题</p>
<h2 id="HTML-base-元素"><a href="#HTML-base-元素" class="headerlink" title="HTML base 元素"></a>HTML base 元素</h2><p>base 标签为页面上的所有链接规定默认地址或默认目标（target）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn/images/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML-link-元素"><a href="#HTML-link-元素" class="headerlink" title="HTML link 元素"></a>HTML link 元素</h2><p>link 标签定义文档与外部资源之间的关系。</p>
<p>link 标签最常用于连接样式表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML-style-元素"><a href="#HTML-style-元素" class="headerlink" title="HTML style 元素"></a>HTML style 元素</h2><p>style 标签用于为 HTML 文档定义样式信息。</p>
<p>您可以在 style 元素内规定 HTML 元素在浏览器中呈现的样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTML-meta-元素"><a href="#HTML-meta-元素" class="headerlink" title="HTML meta 元素"></a>HTML meta 元素</h2><p>meta 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。</p>
<p>典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据</p>
<p>一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下面的 meta 元素定义页面的描述--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Free Web tutorials on HTML, CSS, XML&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--下面的 meta 元素定义页面的关键词--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, XML&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTML-script-元素"><a href="#HTML-script-元素" class="headerlink" title="HTML script 元素"></a>HTML script 元素</h2><p>script 标签用于定义客户端脚本，比如 JavaScript</p>
<h1 id="HTML-布局"><a href="#HTML-布局" class="headerlink" title="HTML 布局"></a>HTML 布局</h1><h2 id="使用-div-元素的-HTML-布局"><a href="#使用-div-元素的-HTML-布局" class="headerlink" title="使用 div 元素的 HTML 布局"></a>使用 div 元素的 HTML 布局</h2><p>div 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位</p>
<h2 id="使用-HTML5-的网站布局"><a href="#使用-HTML5-的网站布局" class="headerlink" title="使用 HTML5 的网站布局"></a>使用 HTML5 的网站布局</h2><p>HTML5 提供的新语义元素定义了网页的不同部分：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>定义文档或节的页眉</td>
</tr>
<tr>
<td>nav</td>
<td>定义导航链接的容器</td>
</tr>
<tr>
<td>section</td>
<td>定义文档中的节</td>
</tr>
<tr>
<td>article</td>
<td>定义独立的自包含文章</td>
</tr>
<tr>
<td>aside</td>
<td>定义内容之外的内容（比如侧栏）</td>
</tr>
<tr>
<td>footer</td>
<td>定义文档或节的页脚</td>
</tr>
<tr>
<td>details</td>
<td>定义额外的细节</td>
</tr>
<tr>
<td>summary</td>
<td>定义 details 元素的标题</td>
</tr>
</tbody></table>
<h2 id="使用表格的-HTML-布局"><a href="#使用表格的-HTML-布局" class="headerlink" title="使用表格的 HTML 布局"></a>使用表格的 HTML 布局</h2><p>table 元素不是作为布局工具而设计的。</p>
<p>table 元素的作用是显示表格化的数据。</p>
<p>使用 table 元素能够取得布局效果，因为能够通过 CSS 设置表格元素的样式</p>
<h1 id="HTML-响应式设计"><a href="#HTML-响应式设计" class="headerlink" title="HTML 响应式设计"></a>HTML 响应式设计</h1><p>响应式设计RWD能够以可变尺寸传递网页，对于平板和移动设备是必需的</p>
<h2 id="使用-Bootstrap"><a href="#使用-Bootstrap" class="headerlink" title="使用 Bootstrap"></a>使用 Bootstrap</h2><p>使用现成的 CSS 框架。</p>
<p>Bootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jumbotron&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3School Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Resize this responsive page!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>London is the capital city of England.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is the most populous city in the United Kingdom,</span><br><span class="line">    with a metropolitan area of over 13 million inhabitants.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Paris<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paris is the capital and most populous city of France.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Tokyo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">    and the most populous metropolitan area in the world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 简介</title>
    <url>/2021/04/01/html/html-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>HTML 是用来描述网页的一种语言。<br>HTML 不是一种编程语言，而是一种标记语言<br>HTML 使用标记标签来描述网页<br>HTML文档也叫做 web 页面</p>
<span id="more"></span>
<h1 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h2><p><code>&lt;!DOCTYPE html&gt;</code> 声明为 HTML5 文档<br><code>&lt;html&gt;</code> 元素是 HTML 页面的根元素<br><code>&lt;head&gt;</code> 元素包含了文档的元（meta）数据，如 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 定义网页编码格式为 utf-8。<br><code>&lt;title&gt;</code> 元素描述了文档的标题<br><code>&lt;body&gt;</code> 元素包含了可见的页面内容<br><code>&lt;h1&gt;</code> 元素定义一个大标题<br><code>&lt;p&gt;</code> 元素定义一个段落</p>
<h1 id="lt-DOCTYPE-gt-声明"><a href="#lt-DOCTYPE-gt-声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h1><p><code>&lt;!DOCTYPE&gt;</code>声明有助于浏览器中正确显示网页。<br>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。<br>doctype声明是不区分大小写的，以下方式均可<br><strong>html5</strong>的通用声明：<code>&lt;!DOCTYPE html&gt;</code></p>
<h1 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h1><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 <strong>UTF-8</strong> 或 <strong>GBK</strong>。<br>在<code>&lt;head&gt;</code>下一行声明<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础6</title>
    <url>/2021/04/03/html/html-%E5%9F%BA%E7%A1%806/</url>
    <content><![CDATA[<h1 id="HTML-计算机代码元素"><a href="#HTML-计算机代码元素" class="headerlink" title="HTML 计算机代码元素"></a>HTML 计算机代码元素</h1><p>HTML code 元素定义编程代码示例,不保留多余的空格和折行,如需解决该问题，必须在 pre 元素中包围代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Coding Example:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">var person = &#123;</span><br><span class="line">    firstName:&quot;Bill&quot;,</span><br><span class="line">    lastName:&quot;Gates&quot;,</span><br><span class="line">    age:50,</span><br><span class="line">    eyeColor:&quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>HTML var 元素定义数学变量：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Einstein wrote:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">var</span>&gt;</span>E = m c<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Einstein wrote:</p>

<p><var>E = m c<sup>2</sup></var></p>

<h1 id="HTML5-语义元素"><a href="#HTML5-语义元素" class="headerlink" title="HTML5 语义元素"></a>HTML5 语义元素</h1><p>语义元素清楚地向浏览器和开发者描述其意义。</p>
<p>非语义元素的例子：div 和 span - 无法提供关于其内容的信息。</p>
<p>语义元素的例子：form、table 以及 img - 清晰地定义其内容。</p>
<p>HTML5 提供了定义页面不同部分的新语义元素：</p>
<p>article，aside，details，figcaption，figure，footer，header，main，mark，nav，section，summary，time</p>
<h1 id="HTML5-代码约定"><a href="#HTML5-代码约定" class="headerlink" title="HTML5 代码约定"></a>HTML5 代码约定</h1><ol>
<li>请使用正确的文档类型 <code>&lt;!DOCTYPE html&gt;</code></li>
<li>请使用小写元素名</li>
<li>关闭所有 HTML 元素</li>
<li>关闭空的 HTML 元素 <code>&lt;meta charset=&quot;utf-8&quot; /&gt; </code></li>
<li>使用小写属性名 <code>&lt;div class=&quot;menu&quot;&gt;</code></li>
<li>属性值加引号 <code>&lt;table class=&quot;table striped&quot;&gt;</code></li>
<li>请始终对图像使用 alt 属性,当图像无法显示时该属性很重要</li>
<li>请始终定义图像尺寸。这样做会减少闪烁，因为浏览器会在图像加载之前为图像预留空间。</li>
<li>精简空格 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;</code></li>
<li>避免长代码行</li>
<li>请勿毫无理由地增加空行。为了提高可读性，请增加空行来分隔大型或逻辑代码块。为了提高可读性，请增加两个空格的缩进。请勿使用 TAB。</li>
</ol>
<h1 id="HTML-字符实体"><a href="#HTML-字符实体" class="headerlink" title="HTML 字符实体"></a>HTML 字符实体</h1><p>HTML 中的预留字符必须被替换为字符实体<br>常用：<br>空格 <code>&amp;nbsp;</code>  双引号 <code>&amp;quot;</code>  单引号 <code>&amp;apos;</code><br>乘号 <code>&amp;times;</code> 除号 <code>&amp;divide;</code></p>
<h1 id="HTML-URL"><a href="#HTML-URL" class="headerlink" title="HTML URL"></a>HTML URL</h1><p>统一资源定位器（URL）用于定位万维网上的文档（或其他数据）<br>格式：<code>scheme://host.domain:port/path/filename</code><br>scheme - 定义因特网服务的类型。最常见的类型是 http<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网域名，比如 w3school.com.cn<br>:port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p>
<h1 id="HTML-框架"><a href="#HTML-框架" class="headerlink" title="HTML 框架"></a>HTML 框架</h1><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。</p>
<p>使用框架的坏处：开发人员必须同时跟踪更多的HTML文档；很难打印整张页面</p>
<p>框架结构标签（frameset）定义如何将窗口分割为框架,每个 frameset 定义了一系列行或列,rows/columns 的值规定了每行或每列占据屏幕的面积</p>
<p>Frame 标签定义了放置在每个框架中的 HTML 文档。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,75%&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_a.htm&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_b.htm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="HTML-背景"><a href="#HTML-背景" class="headerlink" title="HTML 背景"></a>HTML 背景</h1><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;rgb(0,0,0)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片背景"><a href="#图片背景" class="headerlink" title="图片背景"></a>图片背景</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;clouds.gif&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;http://www.w3school.com.cn/clouds.gif&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 表单</title>
    <url>/2021/04/03/html/html-%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="html表单"><a href="#html表单" class="headerlink" title="html表单"></a>html表单</h1><p>HTML 表单用于搜集不同类型的用户输入。</p>
<span id="more"></span>
<p><strong>form</strong> 元素定义 HTML 表单<br>HTML 表单包含表单元素。表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。</p>
<h1 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h1><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>accept-charset</td>
<td>规定用于表单提交的字符编码。</td>
</tr>
<tr>
<td>action</td>
<td>规定提交表单时将表单数据发送到何处。</td>
</tr>
<tr>
<td>autocomplete</td>
<td>规定表单是否应打开自动完成（填写）功能。</td>
</tr>
<tr>
<td>enctype</td>
<td>规定将表单数据提交到服务器时应如何编码（仅供 method=”post”）。</td>
</tr>
<tr>
<td>method</td>
<td>规定发送表单数据时要使用的 HTTP 方法。</td>
</tr>
<tr>
<td>name</td>
<td>规定表单名称。</td>
</tr>
<tr>
<td>novalidate</td>
<td>规定提交时不应验证表单。</td>
</tr>
<tr>
<td>rel</td>
<td>规定链接资源和当前文档之间的关系。</td>
</tr>
<tr>
<td>target</td>
<td>规定提交表单后在何处显示接收到的响应。</td>
</tr>
</tbody></table>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p><strong>如果省略 action 属性，则将 action 设置为当前页面</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交后，将表单数据发送到 &quot;action_page.php&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/action_page.php&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fname&quot;</span>&gt;</span>First name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bill&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lname&quot;</span>&gt;</span>Last name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Gates&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<form action="/action_page.php">
  <label for="fname">First name:</label><br>
  <input type="text" id="fname" name="fname" value="Bill"><br>
  <label for="lname">Last name:</label><br>
  <input type="text" id="lname" name="lname" value="Gates"><br><br>
  <input type="submit" value="Submit">
</form>

<h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>默认值为 _self，这意味着响应将在当前窗口中打开。</p>
<p>target的值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_blank</td>
<td>响应显示在新窗口或选项卡中。</td>
</tr>
<tr>
<td>_self</td>
<td>响应显示在当前窗口中。</td>
</tr>
<tr>
<td>_parent</td>
<td>响应显示在父框架中。</td>
</tr>
<tr>
<td>_top</td>
<td>响应显示在窗口的整个 body 中。</td>
</tr>
<tr>
<td>framename</td>
<td>响应显示在命名的 iframe 中。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交的结果将在新的浏览器标签中打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/action_page.php&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>method 属性指定提交表单数据时要使用的 HTTP 方法。</p>
<p>表单数据可以作为 URL 变量（使用 method=”get”）或作为 HTTP post 事务（使用 method=”post”）发送。</p>
<p>提交表单数据时，默认的 HTTP 方法是 GET。</p>
<h1 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h1><h2 id="input元素"><a href="#input元素" class="headerlink" title="input元素"></a>input元素</h2><h3 id="输入类型：text"><a href="#输入类型：text" class="headerlink" title="输入类型：text"></a>输入类型：text</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<form>
 First name:<br>
<input type="text" name="firstname">
<br>
 Last name:<br>
<input type="text" name="lastname">
</form> 

<h3 id="输入类型：password"><a href="#输入类型：password" class="headerlink" title="输入类型：password"></a>输入类型：password</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入类型：submit"><a href="#输入类型：submit" class="headerlink" title="输入类型：submit"></a>输入类型：submit</h3><p>input type=”submit” 定义提交表单数据至表单处理程序的按钮。</p>
<p><strong>表单处理程序</strong>通常是包含处理输入数据的脚本的服务器页面。</p>
<p>在表单的 action 属性中规定表单处理程序：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span></span><br><span class="line">First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mickey&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mouse&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="输入类型：radio"><a href="#输入类型：radio" class="headerlink" title="输入类型：radio"></a>输入类型：radio</h3><p>定义单选按钮</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<form>
<input type="radio" name="sex" value="male" checked>Male
<br>
<input type="radio" name="sex" value="female">Female
</form> 

<h3 id="输入类型：checkbox"><a href="#输入类型：checkbox" class="headerlink" title="输入类型：checkbox"></a>输入类型：checkbox</h3><p>定义复选框</p>
<h3 id="输入类型：buttom"><a href="#输入类型：buttom" class="headerlink" title="输入类型：buttom"></a>输入类型：buttom</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me!&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<input type="button" onclick="alert('Hello World!')" value="Click Me!">

<h3 id="输入类型：number"><a href="#输入类型：number" class="headerlink" title="输入类型：number"></a>输入类型：number</h3><p>用于应该包含数字值的输入字段，能够对数字做出限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  Quantity (between 1 and 5):</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;quantity&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<form>
  Quantity (between 1 and 5):
  <input type="number" name="quantity" min="1" max="5">
</form>

<h2 id="input属性"><a href="#input属性" class="headerlink" title="input属性"></a>input属性</h2><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>value 属性规定输入字段的初始值</p>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>属性规定输入字段为只读（不能修改）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<form action="">
 First name:<br>
<input type="text" name="firstname" value="John" readonly>
<br>
 Last name:<br>
<input type="text" name="lastname">
</form> 

<h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3><p>disabled 属性规定输入字段是禁用的。</p>
<p>被禁用的元素是不可用和不可点击的。</p>
<p>被禁用的元素不会被提交。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size 属性规定输入字段的尺寸（以字符计）</p>
<h3 id="maxlength"><a href="#maxlength" class="headerlink" title="maxlength"></a>maxlength</h3><p>maxlength 属性规定输入字段允许的最大长度</p>
<h3 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h3><p>autocomplete 属性规定表单或输入字段是否应该自动完成。</p>
<p>当自动完成开启，浏览器会基于用户之前的输入值自动填写值。</p>
<h3 id="novalidate"><a href="#novalidate" class="headerlink" title="novalidate"></a>novalidate</h3><p>如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证</p>
<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>form 属性规定 <code>&lt;input&gt;</code> 元素所属的一个或多个表单<br>使得input元素可以在表单外</p>
<h2 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h2><p>定义下拉列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>

<h2 id="option元素"><a href="#option元素" class="headerlink" title="option元素"></a>option元素</h2><p>定义待选择的选项。</p>
<p>列表通常会把首个选项显示为被选选项</p>
<p>您能够通过添加 selected 属性来定义预定义选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span> <span class="attr">selected</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure>
<option value="fiat" selected>Fiat</option>

<h2 id="textarea元素"><a href="#textarea元素" class="headerlink" title="textarea元素"></a>textarea元素</h2><p>定义多行输入字段（文本域）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<textarea name="message" rows="10" cols="30">
The cat was playing in the garden.
</textarea>

<h2 id="HTML5-datalist元素"><a href="#HTML5-datalist元素" class="headerlink" title="HTML5 datalist元素"></a>HTML5 datalist元素</h2><p>为 input 元素规定预定义选项列表。</p>
<p>用户会在他们输入数据时看到预定义选项的下拉列表。</p>
<p>input 元素的 list 属性必须引用 datalist 元素的 id 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Internet Explorer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chrome&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Safari&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<form action="action_page.php">
<input list="browsers">
<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist> 
</form>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html表单</tag>
      </tags>
  </entry>
  <entry>
    <title>html 类</title>
    <url>/2021/04/02/html/html-%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="html-类"><a href="#html-类" class="headerlink" title="html 类"></a>html 类</h1><p>对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。<br>为相同的类设置相同的样式，或者为不同的类设置不同的样式。</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml">.cities &#123;  <span class="comment">&lt;!--类定义--&gt;</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分类块级元素"><a href="#分类块级元素" class="headerlink" title="分类块级元素"></a>分类块级元素</h2><p>HTML <code>&lt;div&gt;</code> 元素是块级元素。它能够用作其他 HTML 元素的容器。</p>
<p>设置 <code>&lt;div&gt;</code> 元素的类，使我们能够为相同的 <code>&lt;div&gt;</code> 元素设置相同的类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.cities &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Paris<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paris is the capital and most populous city of France.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Tokyo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">and the most populous metropolitan area in the world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分类行内元素"><a href="#分类行内元素" class="headerlink" title="分类行内元素"></a>分类行内元素</h2><p>HTML <code>&lt;span&gt;</code> 元素是行内元素，能够用作文本的容器。</p>
<p>设置 <code>&lt;span&gt;</code> 元素的类，能够为相同的 <code>&lt;span&gt;</code> 元素设置相同的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span><span class="selector-class">.red</span> &#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Important<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html类</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数2</title>
    <url>/2021/04/05/javascript/Javascript-%E5%87%BD%E6%95%B02/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在一个对象中绑定函数，称为这个对象的<strong>方法</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<strong>this关键字</strong>:<br>在一个方法内部，this是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。</p>
<p>如果拆开写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>可见，成员函数必须以方法的形式调用，单独调用时，this的指向是全局变量window</p>
<p>如果这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>也是错误的，为了保证this的指向正确，必须以方法的形式调用函数</p>
<p>如果在对象内部的函数里又定义了一个函数，最内部的函数的this不会指向对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>修复办法：<strong>使用that变量捕获this</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>要<strong>指定函数的this指向哪个对象</strong>，可以用<strong>函数本身</strong>的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>

<p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<ol>
<li>apply()把参数打包成Array再传入；</li>
<li>call()把参数按顺序传入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把this绑定为null。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;count = &#x27;</span> + count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>注意，javascript是可以直接返回函数的（函数也是对象）</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map()是array的一个方法，接受一个函数fun()，对数组中的所有元素执行fun()并返回一个新数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p>把Array的所有数字转为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span></span><br><span class="line"><span class="comment">//String()，数字变字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须<strong>接收两个参数</strong>，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。</p>
<p>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>

<p>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element); <span class="comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 依次打印0, 1, 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(self); <span class="comment">// self就是变量arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>利用filter，可以巧妙地去除Array的重复元素,去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    r,</span><br><span class="line">    arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index; <span class="comment">//apple,strawberry,banana,pear,orange</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>这是因为Array的sort()方法<strong>默认把所有元素先转换为String再排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>

<p>sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，我们可以这么写：（默认升序）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">//[1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure>
<p>sort()方法会直接对Array进行修改，它返回的结果仍是当前Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = a1.sort();</span><br><span class="line">a1; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a2; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Array提供的其他高阶函数"><a href="#Array提供的其他高阶函数" class="headerlink" title="Array提供的其他高阶函数"></a>Array提供的其他高阶函数</h2><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>every()方法可以判断数组的所有元素是否满足测试条件。</p>
<p>都满足则返回true，否则返回false</p>
<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined</p>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p>findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值.</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Map与Set</title>
    <url>/2021/04/04/javascript/Javascript-Map%E4%B8%8ESet/</url>
    <content><![CDATA[<p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>从而引入了Map</p>
<span id="more"></span>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是一组键值对的结构，具有极快的查找速度，无论这个表有多大，查找速度都不会变慢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个空Map。</p>
<p>Map具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在Set中<strong>自动被过滤</strong></p>
<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果</p>
<p>通过delete(key)方法可以删除元素</p>
<h1 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h1><p>ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。</p>
<p>具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ar a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用iterable内置的forEach方法，它<strong>接收一个函数</strong>，每次迭代就自动回调该函数。以<strong>Array</strong>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">&#x27;, index = &#x27;</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//A, index = 0</span></span><br><span class="line"><span class="comment">//B, index = 1</span></span><br><span class="line"><span class="comment">//C, index = 2</span></span><br></pre></td></tr></table></figure>
<p><strong>Set</strong>与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Map</strong>的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数1</title>
    <url>/2021/04/04/javascript/Javascript-%E5%87%BD%E6%95%B01/</url>
    <content><![CDATA[<h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li>function指出这是一个函数定义；</li>
<li>abs是函数的名称；</li>
<li>(x)括号内列出函数的参数，多个参数以,分隔；</li>
<li>{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ol>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是<strong>结果为undefined</strong>。</p>
<p>由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以<strong>视为指向该函数的变量</strong>。</p>
<p>从而，第二种定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种方式下，function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。</p>
<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>调用函数时，按顺序传入参数即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>传入的参数比定义的<strong>少</strong>也没有问题,此时abs(x)函数的参数x将收到undefined，计算结果为NaN:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(); <span class="comment">// 返回NaN</span></span><br></pre></td></tr></table></figure>
<p>要避免收到undefined，可以<strong>对参数进行检查</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>关键字arguments，它只在<strong>函数内部</strong>起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">/*x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 30*/</span></span><br></pre></td></tr></table></figure>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>如果传入的参数大于函数需要的参数，获取多余的参数可以用rest<br>注意，rest必须写在最后，并且形式为…rest</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<p>传入的参数先绑定a、b，多余的参数以数组形式交给变量rest</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;rest.length;i++)</span><br><span class="line">       sum=sum+rest[i];</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line"> &#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);  <span class="comment">//输出55</span></span><br></pre></td></tr></table></figure>
<p>如果传入的参数连正常定义的参数都没填满，rest参数会接收一个空数组（注意不是undefined）。</p>
<h2 id="小心return语句"><a href="#小心return语句" class="headerlink" title="小心return语句"></a>小心return语句</h2><p>JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆成两行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际变成了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于return undefined;</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的多行写法是</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量作用域与解构赋值"><a href="#变量作用域与解构赋值" class="headerlink" title="变量作用域与解构赋值"></a>变量作用域与解构赋值</h1><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>
<ol>
<li>如果一个变量在<strong>函数体内部</strong>声明，则该变量的作用域为整个函数体，在函数体外不可引用该变量</li>
<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果内部函数和外部函数的变量名<strong>重名</strong>,则内部函数屏蔽外部定义的变量，不影响外部定义的变量</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，<font color="red">但不会提升变量的赋值</font></p>
<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，<strong>请严格遵守“在函数内部首先申明所有变量”这一规则</strong>。最常见的做法是用一个var申明函数内部用到的所有变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">        y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">        z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line">    <span class="comment">// 其他语句:</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<strong>window</strong>，全局作用域的变量实际上被绑定到window的一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">&#x27;Learn JavaScript&#x27;</span>;</span><br><span class="line">alert(course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，<strong>顶层函数的定义也被视为一个全局变量</strong>，并绑定到window对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 直接调用foo()</span></span><br><span class="line"><span class="built_in">window</span>.foo(); <span class="comment">// 通过window.foo()调用</span></span><br></pre></td></tr></table></figure>
<p>我们每次直接调用的alert()函数其实也是window的一个变量</p>
<p>这说明JavaScript实际上<strong>只有一个全局作用域</strong>。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<strong>ReferenceError</strong>错误。</p>
<h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数<strong>全部绑定到一个全局变量中</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">&#x27;myapp&#x27;</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决块级作用域，ES6引入了新的<strong>关键字let</strong>，用let替代var可以申明一个块级作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>从ES6开始，JavaScript引入了解构赋值，可以<strong>同时对一组变量进行赋值</strong>。</p>
<ol>
<li>多个变量同时赋值：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br><span class="line"><span class="comment">// x, y, z分别被赋值为数组对应元素:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x + <span class="string">&#x27;, y = &#x27;</span> + y + <span class="string">&#x27;, z = &#x27;</span> + z);</span><br><span class="line"><span class="comment">//x = hello, y = JavaScript, z = ES6</span></span><br></pre></td></tr></table></figure></li>
<li>数组元素进行解构赋值，多个变量要用[…]括起来:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">&#x27;hello&#x27;</span>, [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]];</span><br><span class="line">x; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">y; <span class="comment">// &#x27;JavaScript&#x27;</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure>
解构赋值还可以<strong>忽略</strong>某些元素：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br><span class="line"><span class="comment">//name = 小明, age = 20, passport = G-12345678</span></span><br></pre></td></tr></table></figure>
对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">        street: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        zipcode: <span class="string">&#x27;100001&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">city; <span class="comment">// &#x27;Beijing&#x27;</span></span><br><span class="line">zip; <span class="comment">// undefined, 因为属性名是zipcode而不是zip</span></span><br><span class="line"><span class="comment">// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:</span></span><br><span class="line">address; <span class="comment">// Uncaught ReferenceError: address is not defined</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。</p>
<p>如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性赋值给变量id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">id; <span class="comment">// &#x27;G-12345678&#x27;</span></span><br><span class="line"><span class="comment">// 注意: passport不是变量，而是为了让变量id获得passport属性:</span></span><br><span class="line">passport; <span class="comment">// Uncaught ReferenceError: passport is not defined</span></span><br></pre></td></tr></table></figure>

<p>解构赋值还可以使用<strong>默认值</strong>，这样就避免了不存在的属性返回undefined的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">single; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure>
<p>这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure>
<h3 id="快速获取当前页面的域名和路径："><a href="#快速获取当前页面的域名和路径：" class="headerlink" title="快速获取当前页面的域名和路径："></a>快速获取当前页面的域名和路径：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数3</title>
    <url>/2021/04/06/javascript/Javascript-%E5%87%BD%E6%95%B03/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</span></span><br><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></span><br><span class="line"><span class="comment">//调用函数f时，才真正计算求和的结果：</span></span><br><span class="line">f(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包”的程序结构拥有极大的威力。</p>
<p>当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数</p>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//局部变量i在作祟</span></span><br><span class="line">f1(); <span class="comment">// 16</span></span><br><span class="line">f2(); <span class="comment">// 16</span></span><br><span class="line">f3(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 4</span></span><br><span class="line">f3(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>注意这里用了一个“<strong>创建一个匿名函数并立刻执行</strong>”的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p>
<p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p><strong>闭包就相当于，你在某一局游戏里身上加的BUFF被你带到了下一局游戏里，所以说威力巨大</strong><br><strong>闭包是内部函数可以访问外部函数的变量，反之亦然</strong></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x =&gt; x * x</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于<strong>匿名函数</strong>，并且简化了函数定义。</p>
<p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数不是一个，就需要用括号()括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br><span class="line"><span class="comment">//正确写法：</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。</p>
<p>箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>generator跟函数很像，定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由function*定义，并且，除了return语句，还可以用yield返回多次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接<strong>调用一个generator</strong>和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法:</p>
<ol>
<li><strong>不断地调用generator对象的next()方法</strong>：<br>next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>第二个方法是直接用<strong>for … of循环迭代generator对象</strong>，这种方式不需要我们自己判断done<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 数据类型</title>
    <url>/2021/04/03/javascript/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 的数据类型，共有六种。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>数值（number）</td>
<td>整数和小数（比如1和3.14）。</td>
</tr>
<tr>
<td>字符串（string）</td>
<td>文本（比如Hello World）。</td>
</tr>
<tr>
<td>布尔值（boolean）</td>
<td>表示真伪的两个特殊值，即true（真）和false（假）。</td>
</tr>
<tr>
<td>undefined</td>
<td>表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</td>
</tr>
<tr>
<td>null</td>
<td>表示空值，即此处的值为空。</td>
</tr>
<tr>
<td>对象（object）</td>
<td>各种值组成的集合。</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>数值、字符串、布尔值这三种类型，合称为<strong>原始类型</strong>（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</p>
<p>对象则称为<strong>合成类型</strong>=的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的<strong>容器</strong>，对象可细分为狭义的对象（object）、数组（array）、函数（function）</p>
<p>至于undefined和null，一般将它们看成两个<strong>特殊值</strong>。</p>
<h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof运算符可以返回一个值的数据类型(一个<strong>字符串</strong>)</p>
<p>数值、字符串、布尔值分别返回number、string、boolean。<br>函数返回function<br>undefined返回undefined。利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对象和null返回object</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>空数组（[]）的类型也是object</strong>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。</p>
<h1 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null, undefined"></a>null, undefined</h1><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，语法效果几乎没区别。<br>在if语句中，它们都会被自动转为false，相等运算符（==）直接报告两者相等。</p>
<h2 id="null-undefined用法与含义"><a href="#null-undefined用法与含义" class="headerlink" title="null,undefined用法与含义"></a>null,undefined用法与含义</h2><p>null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。</p>
<p>undefined表示“未定义”，下面是返回undefined的典型场景<br><font color="red">大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>下列运算符会返回布尔值：</p>
<ol>
<li>前置逻辑运算符： ! (Not)</li>
<li>相等运算符：===，!==，==，!=（===不转换类型，==转换类型再比较）</li>
<li>比较运算符：&gt;，&gt;=，&lt;，&lt;=</li>
<li>逻辑运算：&amp;&amp; ||</li>
</ol>
<p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true:</p>
<ol>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>0</li>
<li>NaN</li>
<li>“”或’’（空字符串）</li>
</ol>
<p>注意，<font color="red">空数组（[]）和空对象（{}）对应的布尔值，都是true</font></p>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="整数与浮点数"><a href="#整数与浮点数" class="headerlink" title="整数与浮点数"></a>整数与浮点数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p>
<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个<strong>阈值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>NaN</strong>这个特殊的Number与所有其他值都不相等，包括它自己。唯一能判断NaN的方法是通过isNaN()函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>根据IEEE754，绝对值小于2的53次方的<strong>整数</strong>，即-2^53 到2^53，都可以精确表示</p>
<p>简单的法则就是，JavaScript 对15位的十进制数都可以精确处理</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p>
<p>如果一个数大于等于2的1024次方，那么就会发生“<strong>正向溢出</strong>”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity</p>
<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“<strong>负向溢出</strong>”，即 JavaScript 无法表示这么小的数，这时会直接返回0</p>
<p>JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>JavaScript的数组可以包括任意数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
<p>另一种<strong>创建数组</strong>的方法是通过Array()函数实现:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br></pre></td></tr></table></figure>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>要取得Array的长度，直接访问length属性</p>
<p>直接给Array的length<strong>赋一个新值</strong>会导致Array大小的变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="修改数组元素"><a href="#修改数组元素" class="headerlink" title="修改数组元素"></a>修改数组元素</h2><p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果通过索引赋值时，<strong>索引超过了范围</strong>，同样会引起Array大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>Array也可以通过indexOf()来<strong>搜索一个指定的元素的位置</strong>，不包含元素则返回-1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>截取Array的部分元素，然后返回一个新的Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果不给slice()传递任何参数，它就会从头到尾截取所有元素,可以很容易地复制一个Array:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h2><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：<br><strong>注意</strong>：空数组继续pop不会报错，而是返回undefined</p>
<h2 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h2><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序,可以传入函数<strong>改变排序方式</strong></p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p>反转数组</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素.<br><strong>前两个参数</strong>是删除的起始位置和删除元素的数目，<strong>随后</strong>是添加的元素，返回被删除的元素组成的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array</p>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<p>实际上，concat()方法可以接收<strong>任意个元素和Array</strong>，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>如果数组的某个元素又是一个Array，则可以形成多维数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>查找元素：arrname[pos1][pos2]…[posn]</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>JavaScript的字符串就是用’’或””括起来的字符表示。</p>
<p>如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p>
<p>如果字符串内部既包含’又包含”，可以用转义字符\来标识，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>要把多个字符串连接起来，可以用+号连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<h3 id="获取字符串某个指定位置的字符"><a href="#获取字符串某个指定位置的字符" class="headerlink" title="获取字符串某个指定位置的字符"></a>获取字符串某个指定位置的字符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>
<p>区别于数组，字符串是<font color="red">不可变的</font></p>
<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>toUpperCase()把一个字符串全部变为大写，toLowerCase()把一个字符串全部变为小写，不操作原串，有返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf()会搜索指定字符串出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>substring()返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript的对象是一种无序的<strong>集合</strong>数据类型，它由若干<strong>键值对</strong>组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.birth; <span class="comment">// 1990</span></span><br></pre></td></tr></table></figure>
<p>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含<strong>特殊字符</strong>，就必须用’’括起来,访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问特殊属性</span></span><br><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line"><span class="comment">//普通名字的属性，.和[]运算符都可行</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure>
<p>访问<strong>不存在的属性</strong>不会报错，而是返回undefined</p>
<h2 id="增加，删除属性"><a href="#增加，删除属性" class="headerlink" title="增加，删除属性"></a>增加，删除属性</h2><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>
<h2 id="检测属性是否存在"><a href="#检测属性是否存在" class="headerlink" title="检测属性是否存在"></a>检测属性是否存在</h2><ol>
<li>如果我们要检测xiaoming是否拥有某一属性，可以用<strong>in操作符</strong>：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming<strong>继承</strong>得到的：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</li>
<li>要判断一个属性是否是xiaoming<strong>自身拥有</strong>的，而不是继承得到的，可以用hasOwnProperty()方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>Javascript</tag>
        <tag>数组</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器2</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A82/</url>
    <content><![CDATA[<h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p>注意：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。</p>
<span id="more"></span>
<p>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p>
<p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对<strong>文件扩展名做检查</strong>（.endsWith)，以便防止用户上传无效格式的文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-file-upload&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.value; <span class="comment">// &#x27;C:\fakepath\test.png&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.endsWith(<span class="string">&#x27;.jpg&#x27;</span>) || filename.endsWith(<span class="string">&#x27;.png&#x27;</span>) || filename.endsWith(<span class="string">&#x27;.gif&#x27;</span>))) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Can only upload image file.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>HTML5新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p>
<p>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-image-file&#x27;</span>),</span><br><span class="line">    info = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-file-info&#x27;</span>),</span><br><span class="line">    preview = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-image-preview&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.style.backgroundImage = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">        info.innerHTML = <span class="string">&#x27;没有选择文件&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.innerHTML = <span class="string">&#x27;文件: &#x27;</span> + file.name + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;大小: &#x27;</span> + file.size + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;修改: &#x27;</span> + file.lastModifiedDate;</span><br><span class="line">    <span class="keyword">if</span> (file.type !== <span class="string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.type !== <span class="string">&#x27;image/png&#x27;</span> &amp;&amp; file.type !== <span class="string">&#x27;image/gif&#x27;</span>) &#123;</span><br><span class="line">        alert(<span class="string">&#x27;不是有效的图片文件!&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            data = e.target.result; <span class="comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span></span><br><span class="line">        preview.style.backgroundImage = <span class="string">&#x27;url(&#x27;</span> + data + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reader.readAsDataURL(file);</span><br></pre></td></tr></table></figure>
<p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当文件读取完成后，自动调用此函数:</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>需要注意：AJAX请求是异步执行的，也就是说，<strong>要通过回调函数获得响应</strong>。</p>
<p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = <span class="string">&#x27;Error code: &#x27;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/categories&#x27;</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;请求已发送，请等待响应...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。</p>
<p>XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。</p>
<p>注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</p>
<p>最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。</p>
<h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p>上面代码的URL使用的是<strong>相对路径</strong>。如果你把它改为’<a href="http://www.sina.com.cn/&#39;%EF%BC%8C%E5%86%8D%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%82%AF%E5%AE%9A%E6%8A%A5%E9%94%99%E3%80%82">http://www.sina.com.cn/&#39;，再运行，肯定报错。</a></p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同（<a href="http://www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。">www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</a></p>
<p>如何突破这个限制，请求外域（就是其他网站）的URL？通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/proxy?url=http://www.sina.com.cn&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<a href="http://my.com,或者是*,本次请求就可以成功./">http://my.com，或者是*，本次请求就可以成功。</a></p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“<strong>简单请求</strong>”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: <span class="string">&#x27;FontAwesome&#x27;</span>;</span><br><span class="line">  src: url(<span class="string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) format(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器3</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A83/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise：ES6中新提供的一个内置类(提到类可以想到new、原型、原型链、实例…)，基于promise可以有效的管理JS中的异步编程，解决传统异步编程+回调函数导致的‘回调地狱’问题。<br>Promise：承诺未来一定会执行</p>
<span id="more"></span>
<h2 id="Promise需要掌握的内容"><a href="#Promise需要掌握的内容" class="headerlink" title="Promise需要掌握的内容"></a>Promise需要掌握的内容</h2><p>从函数有三个角色入手：普通函数、构造函数（类）、普通对象</p>
<p>【普通对象 =&gt; 静态的私有属性方法】<br>promise.all()<br>promise.race()<br>promise.resolve()<br>promise.reject()</p>
<p>【类 =&gt; 原型链上的公共属性和方法】<br>promise.prototype.then()<br>promise.prototype.catch()<br>promise.prototype.finally() [一般不用]<br>【new创建实例】</p>
<h2 id="创建Promise实例"><a href="#创建Promise实例" class="headerlink" title="创建Promise实例"></a>创建Promise实例</h2><p>语法： <code>let 实例 = new Promise([executor])</code></p>
<p>我们在创建一个Promise的实例，需要给Promise传递一个函数，这个函数会立即执行，并且浏览器给它自带两个参数（两个参数也都是函数），这两个参数会改变Promise的状态和值</p>
<p><strong>说明</strong>：</p>
<ol>
<li>必须传一个函数,否则会报错：Uncaught TypeError: Promise resolver undefined is not a function</li>
<li>[executor]是一个函数，我们一般在函数中管控我们的异步编程代码</li>
<li>new Promise的时候就会把executor立即执行</li>
<li>并且给executor函数传递两个实参（两个实参也都是函数）：resolve/reject</li>
</ol>
<h2 id="Promise的两个值"><a href="#Promise的两个值" class="headerlink" title="Promise的两个值"></a>Promise的两个值</h2><h3 id="PromiseStatus"><a href="#PromiseStatus" class="headerlink" title="PromiseStatus"></a>PromiseStatus</h3><p>promise状态（要么是成功态要么是失败态）</p>
<ol>
<li>准备状态pending：new Promise的时候默认状态就是pending</li>
<li>成功状态fulfilled/resolved：一般在异步操作成功后，我们通过执行resolved函数，可以把promise的状态改为resolved</li>
<li>失败状态rejected：一般在异步操作失败后，我们通过执行reject函数，可以把promise的状态改为rejected</li>
</ol>
<p>pending =&gt; resolved / rejected 只要状态一旦更改，则不可以再改变</p>
<h3 id="PromiseValue"><a href="#PromiseValue" class="headerlink" title="PromiseValue"></a>PromiseValue</h3><p>promise的值</p>
<p>不论执行resolve/reject哪个函数，都可以传递值，传递的值最后赋值给PromiseValue</p>
<h2 id="Promise原型链上的公共方法—then"><a href="#Promise原型链上的公共方法—then" class="headerlink" title="Promise原型链上的公共方法—then"></a>Promise原型链上的公共方法—then</h2><p>我们在创建实例的时候可以修改Promise的状态，目的就是为了控制then中的两个方法，哪一个去执行。</p>
<p>then方法：<code>实例.then([状态成功时执行的]，[状态失败时执行的])</code><br>方括号里的是result函数和reason函数</p>
<p>result / reason 接收的是PromiseValue的信息（在executor函数中，基于resolve/reject执行传递的值，就是给promise-value传递的值，并且只能传递一个值，传递第二个实参没用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;NO&#x27;</span>);  <span class="comment">//reject的值可以传给PromiseValue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;OK&#x27;</span>);  <span class="comment">//resolve的值可以传给PromiseValue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`成功：<span class="subst">$&#123;result&#125;</span>`</span>); </span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`失败：<span class="subst">$&#123;reason&#125;</span>`</span>); <span class="comment">//当上面的随机是小于0.5的时候执行reject，也就是把状态改为失败态，从而执行then中的reason这个方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="什么时候执行then？"><a href="#什么时候执行then？" class="headerlink" title="什么时候执行then？"></a>什么时候执行then？</h3><ol>
<li><p> 创建实例时执行的是异步代码：<br>异步请求放置在EXECUTOR中，请求成功或者失败后做啥事情都写在THEN中</p>
</li>
<li><p>创建实例时执行的不是异步代码：</p>
</li>
</ol>
<p>–&gt;EXECUTOR函数中理论上是管控异步编程代码的，但是在开发中，你可以自己随意处理；但是不论怎么处理，THEN中的方法，只会在PROMISE状态变为成功或者失败的状态下才会执行；<br>–&gt;在EXECUTOR函数中执行RESOLVE或者REJECT，并不一定会立即通知THEN中的方法执行；如果在这两个函数执行之前，已经基于THEN把成功或者失败的方法放置好了，则立即通知执行；如果还没有执行过THEN方法，则需要等到THEN执行后，方法放置好，再通知成功或者失败的方法执行！</p>
<h3 id="then的返回值"><a href="#then的返回值" class="headerlink" title="then的返回值"></a>then的返回值</h3><p>每一次执行.then都会返回一个新的Promise实例（初始状态：pending初值：undefined）。这样可以继续.then下去，这就是Promise中的then链机制</p>
<p>下面的例子说明：<br>p2这个实例的成功或者失败状态，是由p1.then这堆代码决定的</p>
<p><strong>第一种情况</strong>：只要p1.then中不论哪个方法执行，只要不报错，新的p2实例的状态都会变为成功态，而方法返回的结果就是p2实例的promise-value值（也就是上一个then执行的返回结果，会传递给下一个then中的方法）；同理，两个方法中，不管哪一个执行报错，P2一定是失败态<br><strong>第二种情况</strong>：如果p1.then中的某个方法执行，返回的是新的Promise实例，则会等待这个Promise的执行结果，作为p2的执行状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;NO&#x27;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;  </span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;  </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p2.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">//=&gt;&#x27;OK@@&#x27;</span></span><br><span class="line">  <span class="comment">// return Promise.resolve(100); //=&gt;P3的状态变为成功，值是100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">0</span>); <span class="comment">//=&gt;P3的状态变为失败，值是0</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span> + result);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all([PROMISE1,PROMISE2,…])：等待所有的PROMISE实例都成功，整体才是成功的（返回新的PROMISE实例），只要有一个实例是失败的，整体实例就是失败的；</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race() 同时发送多个请求，谁先有处理结果（不管结果是成功还是失败），就以谁的结果为主（哪怕是失败的）</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>在项目中，我们会用<code> CATCH(REASON=&gt;&#123;&#125;)</code>代替<code> THEN(NULL,REASON=&gt;&#123;&#125;)</code>，效果是一模一样的（执行CATCH也会返回新的PROMISE实例，里面设置的方法是在实例为失败状态下执行的）</p>
<p>=&gt;在项目中，我们一般THEN中放的是成功执行的，CATCH中放的是失败执行的</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>比如下面的代码：我们输出一个从来没有定义过的变量，会报错，下面的代码也不再执行，但是我们想让下面的代码继续执行，就需要用到try catch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">//=&gt;Uncaught ReferenceError: n is not defined 浏览器抛出异常信息，下面代码就不会再执行了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>try</strong>：把可能会报错的代码放置到try中捕获异常（代码执行一但报错，控制台是不抛出异常的，不会影响后续代码的执行）<br><strong>catch</strong>：catch中捕获到异常信息 （可以把信息上报给服务器）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 把可能会报错的代码放置到TRY中捕获异常（代码执行一但报错，控制台是不抛出异常的，不会影响后续代码的执行）</span></span><br><span class="line"> <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"> <span class="comment">// CATCH中捕获到异常信息 （可以把信息上报给服务器）</span></span><br><span class="line"> <span class="comment">// console.log(error);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 标准对象</title>
    <url>/2021/04/07/javascript/Javascript-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><p>number、boolean和string都有包装对象，可以包装成<strong>object类型</strong>。包装对象用new创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure>
<p>虽然包装对象看上去和原来的值一模一样,但他们的类型已经变为object了。所以，包装对象和原始值用===比较会返回false</p>
<span id="more"></span>
<p>如果我们在使用Number、Boolean和String时<strong>没有写new</strong>，三个函数会被当做普通函数，把任何类型的数据转换为number、boolean和string类型</p>
<p>需要遵守的规则：</p>
<ol>
<li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li>
<li>用parseInt()或parseFloat()来转换任意类型到number；</li>
<li>用String()来<strong>转换任意类型到string</strong>，或者直接调用<strong>某个对象的toString()方法</strong>；</li>
<li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li>
<li>typeof操作符可以判断出number、boolean、string、function和undefined；</li>
<li>**判断Array要使用Array.isArray(arr)**；</li>
<li><strong>判断null请使用myVar === null</strong>；</li>
<li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li>
<li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li>
</ol>
<p>对于3中的tostring()方法，对象null和undefined不具有这个方法</p>
<p>对number类型调用tostring()也会报错，要使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// &#x27;123&#x27;, 注意是两个点！</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>在JavaScript中，Date对象用来表示日期和时间。</p>
<p>要获取<strong>系统当前时间</strong>，用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure>

<p>如果要<strong>创建</strong>一个指定日期和时间的Date对象，可以用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月</strong>。</p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2015-06-24T19:49:22.875+08:00&#x27;</span>);</span><br><span class="line">d; <span class="comment">// 1435146562875</span></span><br></pre></td></tr></table></figure>
<p>但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Date.parse()时传入的字符串使用实际月份01<del>12，转换为Date对象后getMonth()获取的月份值为0</del>11</strong>。</p>
<h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。</p>
<p>JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>和JavaScript的number完全一致</td>
</tr>
<tr>
<td>boolean</td>
<td>就是JavaScript的true或false</td>
</tr>
<tr>
<td>string</td>
<td>就是JavaScript的string</td>
</tr>
<tr>
<td>null</td>
<td>就是JavaScript的null</td>
</tr>
<tr>
<td>array</td>
<td>就是JavaScript的Array表示方式——[]</td>
</tr>
<tr>
<td>object</td>
<td>就是JavaScript的{ … }表示方式</td>
</tr>
</tbody></table>
<p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p>
<p>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;</span></span><br></pre></td></tr></table></figure>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 14,</span></span><br><span class="line"><span class="comment">  &quot;gender&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;height&quot;: 1.65,</span></span><br><span class="line"><span class="comment">  &quot;grade&quot;: null,</span></span><br><span class="line"><span class="comment">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; Middle School&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JavaScript&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Java&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Python&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Lisp&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;skills&#x27;</span>], <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JavaScript&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Java&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Python&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Lisp&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 14,</span></span><br><span class="line"><span class="comment">  &quot;gender&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;height&quot;: 1.65,</span></span><br><span class="line"><span class="comment">  &quot;grade&quot;: null,</span></span><br><span class="line"><span class="comment">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; MIDDLE SCHOOL&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JAVASCRIPT&quot;,</span></span><br><span class="line"><span class="comment">    &quot;JAVA&quot;,</span></span><br><span class="line"><span class="comment">    &quot;PYTHON&quot;,</span></span><br><span class="line"><span class="comment">    &quot;LISP&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>JSON.parse()还可以接收一个函数，用来转换解析出的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>标准对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 简介</title>
    <url>/2021/04/03/javascript/Javascript-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="什么是Javascript？"><a href="#什么是Javascript？" class="headerlink" title="什么是Javascript？"></a>什么是Javascript？</h1><p>JavaScript 是一种轻量级的脚本语言。所谓“<strong>脚本语言</strong>”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。</p>
<p>JavaScript 是一种嵌入式语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O相关的 API，都要靠宿主环境提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p>
<span id="more"></span>
<p>目前，已经嵌入 JavaScript 的<strong>宿主环境</strong>有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p>
<p>从语法角度看，JavaScript语言是一种“<strong>对象模型</strong>”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如<strong>函数式编程</strong>）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。</p>
<p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类：</p>
<ol>
<li>浏览器控制类：操作浏览器</li>
<li>DOM 类：操作网页的各种元素</li>
<li>Web 类：实现互联网的各种功能</li>
</ol>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器1</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A81/</url>
    <content><![CDATA[<h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<span id="more"></span>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p>window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p>对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。</p>
<h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p>navigator对象表示浏览器的信息，最常用的属性包括：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>navigator.appName</td>
<td>浏览器名称</td>
</tr>
<tr>
<td>navigator.appVersion</td>
<td>浏览器版本</td>
</tr>
<tr>
<td>navigator.language</td>
<td>浏览器设置的语言</td>
</tr>
<tr>
<td>navigator.platform</td>
<td>操作系统类型</td>
</tr>
<tr>
<td>navigator.userAgent</td>
<td>浏览器设定的User-Agent字符串</td>
</tr>
</tbody></table>
<p>请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。</p>
<p>正确地判断浏览器信息的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表达式a &amp;&amp; 表达式b :  计算表达式a（也可以是函数）的运算结果，</span></span><br><span class="line"><span class="comment">                      如果为 True, 执行表达式b（或函数），并返回b的结果；</span></span><br><span class="line"><span class="comment">                      如果为 False，返回a的结果；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">表达式a || 表达式b :   计算表达式a（也可以是函数）的运算结果，</span></span><br><span class="line"><span class="comment">                      如果为 Fasle, 执行表达式b（或函数），并返回b的结果；</span></span><br><span class="line"><span class="comment">                      如果为 True，返回a的结果；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>screen对象表示屏幕的信息，常用的属性有：</p>
<p>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>location对象表示当前页面的URL信息</p>
<p>一个<strong>完整的URL</strong>以用location.href获取。要获得URL各个部分的值，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.protocol; <span class="comment">// &#x27;http&#x27;</span></span><br><span class="line">location.host; <span class="comment">// &#x27;www.example.com&#x27;</span></span><br><span class="line">location.port; <span class="comment">// &#x27;8080&#x27;</span></span><br><span class="line">location.pathname; <span class="comment">// &#x27;/path/index.html&#x27;</span></span><br><span class="line">location.search; <span class="comment">// &#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.hash; <span class="comment">// &#x27;TOP&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要<strong>加载一个新页面</strong>，可以调用location.assign()。如果要<strong>重新加载当前页面</strong>，调用location.reload()方法非常方便。</p>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p>
<p>document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;努力学习JavaScript!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html数据</span></span><br><span class="line">&lt;dl id=<span class="string">&quot;drink-menu&quot;</span> style=<span class="string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span><br><span class="line">    &lt;dt&gt;摩卡&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;热摩卡咖啡&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;酸奶&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;北京老酸奶&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;果汁&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<p>用document对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点(Array)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;drink-menu&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;dt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i, s;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;提供的饮料有:&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//提供的饮料有:摩卡,酸奶,果汁,</span></span><br></pre></td></tr></table></figure>
<p>document对象还有一个cookie属性，可以获取当前页面的Cookie。</p>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过document.cookie读取到当前页面的Cookie：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history对象保存了浏览器的历史记录，JavaScript可以调用history对象的<code>back()</code>或<code>forward()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。</p>
<p><strong>任何情况，你都不应该使用history这个对象了。</strong></p>
<h1 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h1><p>DOM是文档对象模型</p>
<p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ol>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ol>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code>，以及CSS选择器<code>document.getElementsByClassName()</code>。</p>
<p><font color="red">注意</font>：<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>返回的是节点数组，精确选择其中的元素还要用下标；选择元素中的全部孩子则需要用.children方法（也是个数组）；选择children中的孩子可以用下标、<code>.firstElementChild</code>和<code>.lastElementChild</code></p>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-table&#x27;</span>).getElementsByTagName(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-div&#x27;</span>).getElementsByClassName(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#q1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h2><p>拿到一个DOM节点后，我们可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种：</p>
<p>一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure>
<p>第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，<strong>保证无法设置任何HTML标签</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">p.style.fontSize = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">&#x27;2em&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h2><p>如果这个DOM节点是<strong>空</strong>的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p>
<p>如果这个DOM节点<strong>不是空</strong>的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;js&quot;</span>&gt;JavaScript&lt;/p&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//把&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;添加到&lt;div id=&quot;list&quot;&gt;的最后一项：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure>
<p>因为我们插入的js节点<strong>已经存在于当前的文档树</strong>，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候我们会<strong>从零创建一个新的节点</strong>，然后插入到指定位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.appendChild(haskell);</span><br></pre></td></tr></table></figure>
<p>动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<code>&lt;style&gt;</code>节点，然后把它添加到<code>&lt;head&gt;</code>节点的末尾，这样就动态地给文档添加了新的CSS定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">d.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">d.innerHTML = <span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>要把子节点插入到指定的位置,可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到referenceElement之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTML结构</span></span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//把Haskell插入到Python之前</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;python&#x27;</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure>
<p>可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    i, c,</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.children.length; i++) &#123;</span><br><span class="line">    c = list.children[i]; <span class="comment">// 拿到第i个子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h2><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<h1 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h1><p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ol>
<li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ol>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用value获得对应的用户输入值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value; <span class="comment">// &#x27;用户输入的值&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方式可以应用于<strong>text、password、hidden以及select</strong>。但是，对于<strong>单选框和复选框</strong>，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;monday&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tuesday&#x27;</span>);</span><br><span class="line">mon.value; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">tue.value; <span class="comment">// &#x27;2&#x27;</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure>
<h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p>设置值和获取值类似，对于<strong>text、password、hidden以及select</strong>，直接设置value就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value = <span class="string">&#x27;test@example.com&#x27;</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure>
<p>对于<strong>单选框和复选框</strong>，设置checked为true或false即可。</p>
<h2 id="html5-控件"><a href="#html5-控件" class="headerlink" title="html5 控件"></a>html5 控件</h2><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;date&quot;</span> value=<span class="string">&quot;2021-04-08&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="date" value="2021-04-08">
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;datetime-local&quot;</span> value=<span class="string">&quot;2015-07-01T02:03:04&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="datetime-local" value="2021-04-08T18:45:04">
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;color&quot;</span> value=<span class="string">&quot;#ff0000&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="color" value="#ff0000">

<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>方式一是通过<code>&lt;form&gt;</code>元素的submit()方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的click事件，在JavaScript代码中提交表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。</p>
<p>因此，第二种方式是响应<code>&lt;form&gt;</code>本身的onsubmit事件，在提交form时作修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5,可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;login-form&quot;</span> method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;input-password&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> id=<span class="string">&quot;md5-password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">    &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-password&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span><br><span class="line">    <span class="comment">// 把用户输入的明文变为MD5:</span></span><br><span class="line">    md5_pwd.value = toMD5(input_pwd.value);</span><br><span class="line">    <span class="comment">// 继续下一步:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 基本语法</title>
    <url>/2021/04/03/javascript/Javascript-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内</p>
<p>语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值</p>
<span id="more"></span>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>变量的声明与赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果只声明未赋值，则变量是<strong>未定义的</strong>(undefined)</p>
<p>使用一个未声明的变量，则会报错</p>
<p>可以同时声明多个变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript 是一种<strong>动态类型</strong>语言，也就是说，<strong>变量的类型没有限制</strong>，变量可以随时更改类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用var重新声明一个已经存在的变量是无效的，如果再次声明且赋值，则会覆盖原值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">//无效，x仍为1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;<span class="comment">//x为2</span></span><br></pre></td></tr></table></figure>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做<strong>变量提升</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//a未定义</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ol>
<li>&amp;&amp;</li>
<li>1两边条件都为true时，结果才为true；</li>
<li>2如果有一个为false，结果就为false；</li>
<li>3当第一个条件为false时，就不再判断后面的条件</li>
</ol>
<p>注意：当数值参与逻辑与运算时，结果为true，那么会返回的会是第二个为真的值；如果结果为false，返回的会是第一个为假的值。</p>
<ol start="2">
<li>||</li>
<li>1只要有一个条件为true时，结果就为true；</li>
<li>2当两个条件都为false时，结果才为false；</li>
<li>3当一个条件为true时，后面的条件不再判断</li>
</ol>
<p>注意：当数值参与逻辑或运算时，结果为true，会返回第一个为真的值；如果结果为false，会返回第二个为假的值；</p>
<ol start="3">
<li>！</li>
<li>1当条件为false时，结果为true；反之亦然。</li>
</ol>
<p>补充：逻辑与的优先级是高于逻辑或的；</p>
<p>比如console.log(3||2&amp;&amp;5||0),会先算2&amp;&amp;5的值为5，然后再3||5—-3，最后再3||0—-3，所以最终结果为3.</p>
<p><strong>补充</strong></p>
<p><code>表达式a &amp;&amp; 表达式b </code>:  计算表达式a（也可以是函数）的运算结果，<br>                      如果为 True, 执行表达式b（或函数），并返回b的结果；<br>                      如果为 False，返回a的结果；</p>
<p><code>表达式a || 表达式b </code>:   计算表达式a（也可以是函数）的运算结果，<br>                      如果为 Fasle, 执行表达式b（或函数），并返回b的结果；<br>                      如果为 True，返回a的结果；</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符指的是用来识别各种值的合法名称。最常见的标识符就是<strong>变量名</strong>和<strong>函数名</strong>。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。</p>
<p>命名规则：</p>
<ol>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9</li>
</ol>
<p>JavaScript 有一些<strong>保留字</strong>，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>用//或/**/包起来的行或数行</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>大括号包围起来的代码块，对于var命令来说，JavaScript 的区块不构成单独的作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值) <span class="comment">//括号里可以是值为布尔值的表达式</span></span><br><span class="line">  语句;</span><br></pre></td></tr></table></figure>
<h2 id="if-else-if结构"><a href="#if-else-if结构" class="headerlink" title="if else if结构"></a>if else if结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔值)</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔值)</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不加break，则之后的每个条件都会判定<br>switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时<strong>不会发生类型转换</strong>。</p>
<h2 id="三运运算符"><a href="#三运运算符" class="headerlink" title="三运运算符:?"></a>三运运算符:?</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式)&#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>break语句用于跳出代码块或循环<br>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环</p>
<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置<br>标签通常与break语句和continue语句配合使用，跳出特定的循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label:  <span class="comment">//label可以是任意的名字（不包括保留字）</span></span><br><span class="line">  语句</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程</title>
    <url>/2021/04/07/javascript/Javascript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> robot = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.6</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>于是我们把它改名为Student，然后创建出xiaoming：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure>
<p>注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br></pre></td></tr></table></figure>
<p>xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用</p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>如果你把xiaoming的原型指向其他对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is flying...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br></pre></td></tr></table></figure>
<p>现在xiaoming已经无法run()了，他已经变成了一只鸟</p>
<p>在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。</p>
<p><strong>在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型</strong>.</p>
<p><strong>Object.create()方法</strong>可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 原型对象:</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    <span class="comment">// 初始化新对象:</span></span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p>
<p>例如，创建一个<strong>Array</strong>对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//其原型链是：</span></span><br><span class="line"><span class="comment">//arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</span></span><br></pre></td></tr></table></figure>
<p>Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。</p>
<p>当我们创建一个<strong>函数</strong>时,函数也是一个对象，它的原型链是：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。</p>
<p>如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要<strong>注意不要把原型链搞得太长</strong>。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>除了直接用{ … }<strong>创建一个对象外</strong>，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<strong>new</strong>调用这个函数，就可以创建一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.hello(); <span class="comment">// Hello, 小明!</span></span><br></pre></td></tr></table></figure>
<p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，<strong>它绑定的this指向新创建的对象</strong>，<strong>并默认返回this</strong>，也就是说，不需要在最后写return this;。</p>
<p>我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;匿名&#x27;</span>; <span class="comment">// 默认值为&#x27;匿名&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.prototype指向xiaoming的原型对象</span></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">xiaoming.grade; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">new</span> PrimaryStudent() ----&gt;</span> P<span class="function"><span class="title">rimaryStudent</span>.prototype ----&gt;</span> O<span class="function"><span class="title">bject</span>.prototype ----&gt;</span> null</span><br></pre></td></tr></table></figure>
<p>如果你想用最简单粗暴的方法这么干：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PrimaryStudent.prototype = Student.prototype;</span><br></pre></td></tr></table></figure>
<p>是不行的。这样使得PrimaryStudent和Student共享一个原型对象，定义PrimaryStudent则无意义。</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。中间对象可以用一个<strong>空函数F</strong>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个inherits()函数可以复用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;Unnamed&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>上面一种实现继承的缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>
<p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Student</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用新的class关键字来编写Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个Student对象代码和前面章节完全一样</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.hello();</span><br></pre></td></tr></table></figure>
<h2 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h2><p>用class定义对象的另一个巨大的好处是继承更方便了。</p>
<p>原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, grade</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础1</title>
    <url>/2021/04/01/html/html-%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="html标题"><a href="#html标题" class="headerlink" title="html标题"></a>html标题</h1><p>HTML 标题（Heading）是通过<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签来定义的<br><strong>例子</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="html段落"><a href="#html段落" class="headerlink" title="html段落"></a>html段落</h1><p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的</p>
<p>在一个段落标签里换行：<code>&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;</code></p>
<p>当显示页面时，浏览器会移除源代码中多余的空格和空行。<strong>所有连续的空格或空行都会被算作一个空格</strong>。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p>
<h1 id="html链接"><a href="#html链接" class="headerlink" title="html链接"></a>html链接</h1><p>HTML 链接是通过标签 <code>&lt;a&gt;</code> 来定义的<br><strong>例子</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 href 属性中指定链接的地址</p>
<h1 id="html图像"><a href="#html图像" class="headerlink" title="html图像"></a>html图像</h1><p>HTML 图像是通过标签 <code>&lt;img&gt;</code> 来定义的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>图像的名称和尺寸是以属性的形式提供的</p>
<h1 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h1><p>起始标签、标签内容和闭合标签构成一个<strong>html元素</strong>，html文档由html元素定义</p>
<p>html允许<strong>元素嵌套</strong></p>
<p><code>&lt;body&gt;</code> 元素定义了 HTML 文档的主体</p>
<p>HTML 标签对大小写不敏感</p>
<h1 id="html属性"><a href="#html属性" class="headerlink" title="html属性"></a>html属性</h1><p>属性可以在元素中添加附加信息<br>属性一般描述于开始标签<br>属性总是以名称/值对的形式出现，比如：name=”value”</p>
<p>属性值应该始终被包括在引号内。<br>双引号是最常用的，不过使用单引号也没有问题。<br>在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=’John “ShotGun” Nelson’</p>
<h1 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h1><p>格式：<code>&lt;!-- 这是一个注释 --&gt;</code></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
