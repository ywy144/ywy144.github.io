<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo基本知识</title>
    <url>/2021/03/30/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h1><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p>
<span id="more"></span>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p>
<p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p>
<h1 id="多个tag"><a href="#多个tag" class="headerlink" title="多个tag"></a>多个tag</h1><p><code>tags: [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]</code></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch1 入门</title>
    <url>/2021/03/30/c++/cpp_ch1_%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>输入一系列数据时，可使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin&gt;&gt;value)</span><br></pre></td></tr></table></figure>
<p>当输入文件结束符时，语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cin&gt;&gt;value</span><br></pre></td></tr></table></figure>
<p>的值为0，从而退出循环<br>文件结束符：<em>windows</em>  <code>ctrl+Z</code>    <em>unix</em>  <code>ctrl+D</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基础语法2</title>
    <url>/2021/04/12/vue_js/Vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%952/</url>
    <content><![CDATA[<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>我们可以通过插值语法直接显示某些数据，但有时我们需要对数据进行一些处理再显示。当然，我们可以直接用插值，但会不美观。</p>
<p>我们可以使用计算属性来解决这个问题，计算属性在Vue实例option中的computed</p>
<span id="more"></span>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>比如实例中有两个字符串，现在要显示两个字符串的拼接，有三种方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插值写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;userName+&#x27; &#x27;+userLanguage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--methods写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;stringCat()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--计算属性写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;stringAppend&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      userName: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      userLanguage: <span class="string">&#x27;zh&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      stringAppend: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.userName+<span class="string">&#x27; &#x27;</span>+<span class="built_in">this</span>.userLanguage;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        stringCat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">this</span>.userName+<span class="string">&#x27; &#x27;</span>+<span class="built_in">this</span>.userLanguage;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>computed在使用的时候与methods不一样（当作一个属性，不需要加()），因而命名的时候最好用名词（非动词+名词，比如getPrice）</p>
<h2 id="复杂使用"><a href="#复杂使用" class="headerlink" title="复杂使用"></a>复杂使用</h2><p>即要对多个数据进行处理并输出，基础使用中的+肯定不可行，需要用循环来实现，因而必须放到computed中（methods也可，但性能差一点）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> <span class="comment">&lt;!--406--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line">      books: [</span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">110</span>, <span class="attr">name</span>:<span class="string">&quot;深入理解计算机系统&quot;</span>, <span class="attr">price</span>:<span class="number">100</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">111</span>, <span class="attr">name</span>:<span class="string">&quot;现代操作系统&quot;</span>, <span class="attr">price</span>:<span class="number">101</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>:<span class="string">&quot;C++ Primer&quot;</span>, <span class="attr">price</span>:<span class="number">102</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>:<span class="string">&quot;TCP/IP详解&quot;</span>, <span class="attr">price</span>:<span class="number">103</span>&#125;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      totalPrice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> sum=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> book <span class="keyword">of</span> <span class="built_in">this</span>.books)</span></span><br><span class="line">          sum+=book.price;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> sum;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a>计算属性的setter和getter</h2><p>实际上，上面的computed写法是一种简写，完整的写法应该如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">      totalPrice: &#123;</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> book <span class="keyword">of</span> <span class="built_in">this</span>.books)</span><br><span class="line">            sum+=book.price;</span><br><span class="line">          <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这就解释了为什么使用计算属性不需要像method那样加<code>()</code>，因为totalPrice实际上是一个对象，拥有set和get两个方法。使用totalPrice时就回来调用里面的get方法。</p>
<p><strong>注意</strong>：set方法几乎从不使用（即直接不写set），此时的计算属性是一个<strong>只读属性</strong>，因而通常使用计算属性用的是上一小节的简写形式</p>
<p>set的用法：set方法定义的函数需要接受一个值用于设定Vue实例里的某个数据</p>
<h2 id="computed和methods的对比"><a href="#computed和methods的对比" class="headerlink" title="computed和methods的对比"></a>computed和methods的对比</h2><p>computed有一个小缓存，如果连续执行相同的内容，那么computed只会执行一次，而methods会执行多次</p>
<p>当然，如果computed用到的数据发生了变化，那么computed仍然会重新执行</p>
<h1 id="v-on（事件监听）"><a href="#v-on（事件监听）" class="headerlink" title="v-on（事件监听）"></a>v-on（事件监听）</h1><p>有时我们需要监听用户事件（点击、拖拽、键盘事件等），这时候可以用v-on指令</p>
<p><strong>v-on介绍</strong>：</p>
<ol>
<li>作用：绑定事件监听器</li>
<li>缩写：@</li>
<li>预期：Function | Inline Statement | Object</li>
<li>参数：event</li>
</ol>
<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>实现两个按钮，点击+号则显示的数+1，点击-号则-1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--写法1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--写法2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.count++;</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.count--;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-on的参数"><a href="#v-on的参数" class="headerlink" title="v-on的参数"></a>v-on的参数</h2><p>当通过methods中定义方法，以供@click调用时，需要注意参数问题：<br><strong>情况一</strong>：如果该方法不需要额外参数，那么方法后的()可以不添加。<br>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</p>
<p><strong>情况二</strong>：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--事件调用的方法没有参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">buttom</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--在事件定义时，写函数时省略了小括号，但方法本身需要参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click(&#x27;123&#x27;)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">buttom</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click()&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">buttom</span>&gt;</span> <span class="comment">&lt;!--输出undefined,&#x27;---&#x27;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">buttom</span>&gt;</span> <span class="comment">&lt;!--Vue会默认把浏览器产生的event事件对象作为参数传入--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--在事件定义时，函数同时需要参数和event事件对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">buttom</span>&gt;</span> <span class="comment">&lt;!--event对象赋给了abc，而函数第二个形参变成了undefined--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;123&#x27;,event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">buttom</span>&gt;</span> <span class="comment">&lt;!--报错，会把传入的event当作变量或函数，但是找不到--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buttom</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;123&#x27;,$event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">buttom</span>&gt;</span> <span class="comment">&lt;!--手动获取浏览器产生的event对象，要加$--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    method: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn1Click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn2Click</span>(<span class="params">abc</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(abc,<span class="string">&#x27;-----&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn3Click</span>(<span class="params">abc,event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(abc,event);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a>v-on修饰符</h2><p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。</p>
<p>Vue提供了修饰符来帮助我们方便的处理一些事件：</p>
<ol>
<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>
<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>
<li><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
<li><code>.once</code> - 只触发一次回调。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;&quot;</span><span class="attr">divClick</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    method: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">divClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;divClick&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于事件冒泡，点击按钮的时候，包含按钮的div也会被点击</p>
<p>阻止冒泡，可以写成<code>&lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</code></p>
<p><code>.prevent</code>用于阻止默认事件：</p>
<p><code>.&#123;keyCode | keyAlias&#125;</code>用于监听键盘某个按键的输入：<br>比如我们需要监听用户是否按了回车：<br><code>&lt;input type=&quot;text&quot; @keyup.enter=&quot;KeyUp&quot;&gt;</code><br>注意@后面跟的不是click，监听什么按键，就在keyup后加什么按键，KeyUp是监听到按键后调用的函数</p>
<p>单单就一个keyup，则监听所有按键</p>
<h1 id="v-if、v-else-if、v-else"><a href="#v-if、v-else-if、v-else" class="headerlink" title="v-if、v-else-if、v-else"></a>v-if、v-else-if、v-else</h1><p>v-if、v-else-if、v-else：</p>
<ol>
<li>这三个指令与JavaScript的条件语句if、else、else if类似。</li>
<li>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件</li>
</ol>
<p>v-if的<strong>原理</strong>：<br>v-if后面的条件为false时，对应的元素以及其子元素不会渲染，也就是根本没有不会有对应的标签出现在DOM中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      isShow: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-if与v-else结合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>isShow = false<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：v-if和v-else要处在被vue实例挂在的元素内</p>
<p>v-if-else的使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;score&gt;90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上，这种方式过于麻烦，一般用一个computed代替</p>
<h2 id="条件渲染案例"><a href="#条件渲染案例" class="headerlink" title="条件渲染案例"></a>条件渲染案例</h2><p>案例：用户登录时可以选择用户名登陆和邮箱登录</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUserName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;userEmail&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;!isUserName&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      isUserName: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。</p>
<p>这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的<strong>复用</strong>已经存在的元素，而不是重新创建新的元素。</p>
<p>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key,并且我们需要保证key的不同</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username_input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email_input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;userEmail&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h1><p>v-show的用法和v-if非常相似<code>v-show=&quot;xxx&quot;</code>(xxx是一个布尔值或者能转换为布尔值的表达式），也用于决定一个元素是否渲染</p>
<p>v-if和v-show<strong>对比</strong>:</p>
<ol>
<li>v-if当条件为false时，压根不会有对应的元素在DOM中。</li>
<li>v-show当条件为false时，仅仅是将元素的display属性设置为none而已。</li>
</ol>
<p>开发中如何选择呢？</p>
<ol>
<li>当需要在显示与隐藏之间切片很频繁时，使用v-show</li>
<li>当只有一次切换时，通过使用v-if</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>computed</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch2 变量与基本内置类型</title>
    <url>/2021/03/30/c++/cpp_ch2_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h1><h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p><code>bool, char, wchar_t, char16_t, char32_t, short, int, long,  long long, float, double, long double</code></p>
<span id="more"></span>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><strong>①整型字面值</strong><br>十进制 <code>20</code>     八进制  <code>020</code>    十六进制<code>0x20 0X20</code><br>十进制字面值的默认类型是<code>int long longlong</code>中能容纳的，且位数最少的，比如2为<code>int</code>，2^17为<code>long</code><br><strong>②浮点数字面值</strong>：默认为<code>double</code><br><strong>③字符字面值</strong>：默认为<code>char</code>，如<code>&#39;a&#39;</code>；字符串为<code>char</code>的数组，如<code>&quot;ab&quot;</code><br><strong>④布尔字面值</strong>：<code>true</code>和<code>false</code><br><strong>⑤指针字面值</strong>：<code>nullptr</code><br><strong>⑥转义序列：</strong></p>
<table>
<thead>
<tr>
<th>column0</th>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>换行符：<code>\n</code></td>
<td>横向制表符：<code>\t</code></td>
<td>纵向制表符：<code>\v</code></td>
</tr>
<tr>
<td>退格符：<code>\b</code></td>
<td>回车符：<code>\r</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>用法</strong>：<code>std::cout&lt;&lt;&quot;Hello!&quot;&lt;&lt;&#39;\n&#39;;</code><br><strong>通过添加前缀，后缀可以指定（改变）字面值的类型</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><font color=#FF0000>初始化与赋值不同，初始化是创建变量时给定一个值，赋值是消去原有值并给定新值</font></p>
<h2 id="列表初始化（C-11新特性）"><a href="#列表初始化（C-11新特性）" class="headerlink" title="列表初始化（C++11新特性）"></a>列表初始化（C++11新特性）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下都是正确的</span></span><br><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>对内置类型变量用列表初始化时，<strong>如果存在丢失数据的可能，则编译器报错</strong>，比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="number">1</span>d = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;; <span class="comment">// 错误:转换未执行，因为存在丢失信息的危险</span></span><br><span class="line">int c(ld)， d = ld;  //正确:转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>①对于<strong>内置基本类型</strong>：函数体外默认为0，函数体内不作初始化（访问或拷贝将出错）<br>②<strong>自定义类</strong>的默认初始化行为自定义（如<code>string</code>默认初始化为空串）<br>例子：<code>double a=b=3.14   //b未定义，若b已定义，则最终a=b</code><br><font color=#FF0000>使用未初始化变量可能造成程序错误，甚至时对时错，因而最好初始化每个变量</font></p>
<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><p>当一个程序要使用其他地方（.h）的名字时，要进行声明（比如用某个头文件里的变量名字a）。<br><strong>声明与定义的差异</strong>：<br>（1）变量在所有相关文件中只能定义一次，可以声明无数次（某个程序要用到其他地方的变量则需要声明）；<br>（2）声明规定了变量的类型和名字，而定义还额外申请存储空间，给定一个初始值<br><strong>关键字</strong><code>extern</code>：<br><code>extern int a; //只声明不定义</code><br>若写成<code>extern int a=10</code>，则<code>extern</code>失效<br><font color=#FF0000>函数体内初始化一个extern标记的变量会出错</font></p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>最好在使用变量的时候定义它<br>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明:函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; <span class="comment">// reused 拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">// unique 拥有块作用域</span></span><br><span class="line"><span class="comment">//输出#1:使用全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量reused,覆盖了全局变量reused</span></span><br><span class="line"><span class="comment">//输出#2:使用局部变量reused;输出0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//输出#3:显式地访问全局变量reused;输出42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 复合类型</span><br><span class="line">## 引用</span><br><span class="line">引用(reference)为对象起了另外-一个名字，引用类型引用(refers to)另外一种类型。</span><br><span class="line">通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">int ival &#x3D; 1024;</span><br><span class="line">int &amp;refVal &#x3D; ival;  &#x2F;&#x2F; refVal指向ival (是ival的另一个名字)</span><br><span class="line">int &amp;refVal2;  &#x2F;&#x2F;报错:引用必须被初始化</span><br></pre></td></tr></table></figure>
<p>• 引用必须初始化；引用无法重新绑定到另外一个对象<br>• 引用不是对象，不能定义引用的引用，不允许拷贝<br>• 引用不能绑定字面值，只能绑定对象<br>• 给引用赋值，就是给对应变量赋值</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol>
<li>区别于引用，指针是个对象，可以重新指向其他对象，不一定要初始化，允许拷贝<br>v指针初始化时，=右边必须是地址（&amp;a），不能是变量，也不能是整型（0除外，此时为空指针）</li>
<li><strong>指针初始化</strong>:<code> int *p=&amp;a</code>    ** 指针赋值**：<code>p=&amp;a   //指针p现在指向a    </code><br><code>*p=b   //指针p指向的对象的值改为b</code></li>
<li>获取对象地址:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;</span><br><span class="line"><span class="comment">//P存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></table></figure></li>
<li> 访问指针所指对象：<code>*p</code>，<strong>解引用操作只适合确实有指向对象的指针</strong></li>
<li>注意：不能把某类型的值直接赋给对应指针</li>
</ol>
<h2 id="复合类型声明"><a href="#复合类型声明" class="headerlink" title="复合类型声明"></a>复合类型声明</h2><p>基本类型只有一个，声明符形式多样（*，&amp;是类型修饰符，是声明符的一部分）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i是一个int型的数，p是一个int型指针，r是一个int型引用</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<h2 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>注意r的类型，对于复杂类型，从右往左读，离得最近的符号（&amp;）起最重要的作用<br><font color=#FF0000>*和&amp;只从属于某个声明符，不属于某个类型</font></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>关键字const把变量定义成一个常量，之后不允许修改，并且必须初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_ <span class="built_in">size</span>(); <span class="comment">// 正确:运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>; <span class="comment">//正确:编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;  <span class="comment">//错误:k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>const仅在单一文件内有效，如果想要一个常量在所有文件内有效，则使用extern声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_ 1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="built_in">fcn</span>() ;</span><br><span class="line"><span class="comment">// file_ 1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize; <span class="comment">// 与file_ 1.cc 中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<h2 id="对常量的引用"><a href="#对常量的引用" class="headerlink" title="对常量的引用"></a>对常量的引用</h2><p>显然不能修改引用指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci; <span class="comment">//正确:引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>; <span class="comment">// 错误: r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci; <span class="comment">//错误:试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>
<p>常量只能被常量引用指向，而初始化常量引用不一定要用常量，<strong>允许常量引用绑定非常量、字面值、表达式</strong>，但是不允许用该常量引用修改绑定对象</p>
<h2 id="指向常量的指针和常量指针"><a href="#指向常量的指针和常量指针" class="headerlink" title="指向常量的指针和常量指针"></a>指向常量的指针和常量指针</h2><p>A) 对常量的指针，也不能修改指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi; <span class="comment">//错误: ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确: cptr可以指向一个双精度常量</span></span><br></pre></td></tr></table></figure>
<p>B) 常量指针：指针本身是常量，必须初始化，其指（保存的地址）不能改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">// curErr 将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<p>判断类型：从右往左<br>常量指针不意味着不能通过指针修改绑定对象（取决于对象的类型）</p>
<h2 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h2><p>顶层const表示指针本身是个常量，底层const表示指针指向常量<br>一般地，顶层const可以指所有自身是常量的对象，底层const与引用或指针相关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br></pre></td></tr></table></figure>
<p>两者的区别在于拷贝操作，其中顶层const没有影响；对于底层const，拷入和拷出的对象必须具有相同的底层const资格，或者能相互转换（非常量能变成常量，反之不行）</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式是值不会改变，且在编译过程中就能获得的值（区别于运行阶段）<br>字面值和用常量表达式初始化的常量都是常量表达式，即判定常量表达式只要考察类型和初始值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_ files = <span class="number">20</span>; <span class="comment">// max_ files是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_ files + <span class="number">1</span>; <span class="comment">// limit 是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_ size = <span class="number">27</span>; <span class="comment">// staff_ size不是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_ <span class="built_in">size</span>(); <span class="comment">// sz 不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>【注意，第四个表达式在运行阶段（不是编译阶段）获得值】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constexpr int mf &#x3D; 20; &#x2F;&#x2F; 20是常量表达式</span><br><span class="line">constexpr int limit &#x3D; mf + 1; &#x2F;&#x2F; mf + 1是常量表达式</span><br><span class="line">constexpr int sz &#x3D; size() ; &#x2F;&#x2F;只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<p>A)可以用<code>constexpr</code>函数（该函数简单到在编译时就能获得结果）来初始化<code>constexpr</code>变量<br>B)<code>constexpr</code>的指针初始值必须为<code>nullptr/0</code>，或是某个固定地址的对象（函数体内变量一般不固定地址，不能定义为<code>constexpr</code>，函数体外则可以）<br>C)<code>constexpr</code>定义的指针表示指针是个常量指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">//p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在<br>于<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code> ,从而<code>constexpr</code>指针既可以指向常量，也可以指向非常量</p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;</span><br><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure>
<p><strong>复合类型的别名可能造成错误</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps指向一个指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>; <span class="comment">//对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure>
<h2 id="关键字auto"><a href="#关键字auto" class="headerlink" title="关键字auto"></a>关键字auto</h2><p>让编译器自动推断类型，变量必须被初始化<br>auto能在一个语句里定义多个变量，但是每个变量类型必须相同<br>对于复合类型：<br>1）引用：推断的类型取决于引用的对象<br><code>int i=0,&amp;r=I;  auto b=r;  //b是int</code><br>2）auto会忽略顶层const，保留底层const；若要明确指出顶层const，则需要在auto前加const</p>
<h2 id="关键字decltype"><a href="#关键字decltype" class="headerlink" title="关键字decltype"></a>关键字decltype</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum的 类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure>
<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量,则<code>decltype</code>返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>，&amp;Cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y的类型是const int&amp;, y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z; <span class="comment">//错误:z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>因为cj是一个引用，<code>decltype (cj)</code>的结果就是引用类型，因此作为引用的z必须被初始化。<br>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在<code>decltype</code>处是一个例外。</p>
<p><strong>decltype和引用</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype 的结果可以是引用类型</span></span><br><span class="line">inti=<span class="number">42</span>，*p=&amp;i，&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// 正确:加法的结果是int，因此b是一个(未初始化的) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) C; <span class="comment">//错误:c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>r+0的结果是个int；解引操作*p得到的是引用类型<br>此外，如果给变量套一个括号，编译器会认为这是个变量；套多层括号则会认为是表达式，从而返回引用类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误: d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确: e是一个(未初始化的) int</span></span><br></pre></td></tr></table></figure>
<p>赋值会产生引用类型，如果i是int，则表达式<code>i=a</code>的类型是<code>int&amp;</code></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>变量</tag>
        <tag>基本内置类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基础语法1</title>
    <url>/2021/04/10/vue_js/Vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="mustache语法（文本插值）"><a href="#mustache语法（文本插值）" class="headerlink" title="mustache语法（文本插值）"></a>mustache语法（文本插值）</h1><p>用于数据绑定，由于Vue是响应式，因而实例中数据发生变化，标签里绑定的文本也会变化</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello,&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;language+&#x27; &#x27;+nation&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mustache不仅可以写变量，还可以写表达式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;language&#125;&#125; &#123;&#123;nation&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter * 2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      language: <span class="string">&#x27;zh&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      nation: <span class="string">&#x27;China&#x27;</span>,</span></span><br><span class="line">      counter: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上写了几种常用的mustache用法，注意mustache不仅可以插值变量，也可以是表达式</p>
<h1 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h1><p>有时候我们不希望界面随意改变，这时候可以在标签里加一个v-once指令（阻断响应式）</p>
<p>v-once表示元素或组件只渲染一次，不会随着数据的改变而改变</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时如果修改message的值，第二个<code>&lt;h2&gt;</code>里的内容不会改变</p>
<h1 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h1><p>用于html插值。对于html的一个元素，直接用<code>&#123;&#123;&#125;&#125;`不会得到想要的结果：
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;url&#125;&#125;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="handlebars"><span class="xml">      url: &#x27;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu/com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
这时候需要使用v-html指令：
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

# v-text
效果类似于mustache语法，但是不够灵活
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
两个`<h2>`标签展示的内容是相同的。

但是v-text不够灵活，比如想要输出`ywy144,hello`:
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span>,hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
,hello会被message覆盖。因而实际中，mustache用的更多

# v-pre
阻断mustache里的变量替换（解析），用的很少
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
第二个`<h2>`显示`&#123;&#123;message&#125;&#125;</code>，第一个则显示ywy144</p>
<h1 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h1><p>有时候网页解析的慢，如果没有解析到<code>&lt;script&gt;</code>，则网页最开始会显示<code>&#123;&#123;message&#125;&#125;</code>，之后再变成message的值</p>
<p>利用v-cloak可以让网页在未解析到<code>&lt;script&gt;</code>的时候对包含了v-cloak的标签里的所有元素应用一个css</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: none;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>没有解析到标签对应的Vue实例时，v-cloak会存在于标签中，然后调用对应的css<br>解析到对应的Vue实例时，v-cloak会自动删除，从而对应的css也不会被使用</p>
<p>v-cloak用的很少</p>
<h1 id="v-bind（动态绑定属性）"><a href="#v-bind（动态绑定属性）" class="headerlink" title="v-bind（动态绑定属性）"></a>v-bind（动态绑定属性）</h1><p>mustache语法只能把Vue实例里的数据绑定到标签夹起来的<code>&#123;&#123;&#125;&#125;</code>中，不能塞到标签<code>&lt;&gt;</code>里</p>
<p>但有时候我们需要把<strong>内容绑定到标签的属性值</strong>中，比如绑定到<code>&lt;img src=&quot;xxx&quot;&gt;</code>中的src（接受后台数据放到Vue实例，再通过v-bind动态地改变属性值）</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>某个属性aaa需要被Vue实例中的数据xxxx绑定，则写<code>&lt;tagName v-bind:aaa=&quot;xxxx&quot;&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--错误的写法--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;img scr=&quot;&#123;&#123;imageURL&#125;&#125;&quot; alt=&quot;&quot;&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--正确的写法--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      imageURL: <span class="string">&#x27;https://cn.vuejs.org/images/lifecycle.png&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际开发中，img的src和a的href不会写成固定值，往往要和后台数据绑定并动态变化，因而要使用v-bind</p>
<p>语法糖（v-bind）的<strong>简写</strong>（v-bind用冒号:代替）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imageURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-bind绑定class（对象语法）"><a href="#v-bind绑定class（对象语法）" class="headerlink" title="v-bind绑定class（对象语法）"></a>v-bind绑定class（对象语法）</h2><p>通常，绑定一个class的写法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--css--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      .active&#123;</span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用v-bind则可以写为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（<strong>重要</strong>）如果要动态地改变class（比如点击后变色），则可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tagName</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;类名1:boolean, 类名2:boolean, ...&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tagName</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>class后面跟的是一个<strong>对象</strong>，对象里某个类名的布尔值为true，该类就会添加到class，从而实现某个标签的样式变化只需要调整这个布尔值（可以多个true，从而多个样式绑定）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: true, line: true&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常我们要把布尔值剥离出来（放到Vue实例里）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, line: isLine&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      isActive: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      isLine: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，这种写法:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: isActive, line: isLine&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>会把第一个class和第二个class里为true的合并为一个class，不会造成冲突</p>
<p>最后，如果<code>:class</code>的内容过于复杂，可以放到methods或者computed中（注意this）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      isActive: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      isLine: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getClasses: <span class="function"><span class="keyword">function</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">active</span>: <span class="built_in">this</span>.isActive, <span class="attr">line</span>: <span class="built_in">this</span>.isLine&#125;;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-bind绑定class（数组语法）"><a href="#v-bind绑定class（数组语法）" class="headerlink" title="v-bind绑定class（数组语法）"></a>v-bind绑定class（数组语法）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;,&#x27;line&#x27;]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样，也可以扔到methods中</p>
<p>数组语法用的很少</p>
<h2 id="v-bind绑定style（对象语法）"><a href="#v-bind绑定style（对象语法）" class="headerlink" title="v-bind绑定style（对象语法）"></a>v-bind绑定style（对象语法）</h2><p>格式类似于绑定class，但区别在于绑定style的键值对是属性名和属性值（大括号里可以有多种样式），而绑定class是类名和布尔值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: &#x27;50px&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：50px要打单引号，不然会被认为是变量名，从而去Vue实例中寻找<br>从而可以得出动态style的写法，即去掉单引号，传入一个变量：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: fontsize&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      fontsize: <span class="string">&#x27;50px&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-bind绑定style（数组语法）"><a href="#v-bind绑定style（数组语法）" class="headerlink" title="v-bind绑定style（数组语法）"></a>v-bind绑定style（数组语法）</h2><p>在Vue实例里定义多个对象表示style1(2,…)，然后再<code>:style=[style1, style2, ...]</code></p>
<p>数组语法用的很少</p>
<p>与绑定class一样，如果东西太多，可以扔到Vue实例的methods中（设一个函数，return一个对象/数组）</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件化开发1</title>
    <url>/2021/04/15/vue_js/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<h1 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h1><p>我们将一个页面<strong>拆分成一个个小的功能块</strong>，每个功能块完成属于自己这部分独立的功能，从而使得整个页面的管理和维护变得容易。</p>
<ol>
<li>我们将一个完整的页面分成很多个组件。</li>
<li>每个组件都用于实现页面的一个功能块。</li>
<li>而每一个组件也可以继续拆成小组件。<span id="more"></span>
我们可以开发出一个个独立可复用的小组件来构造我们的应用，任何的应用都会被抽象成一颗组件树。<img src="https://cn.vuejs.org/images/components.png">
<!--more-->
# 组件使用的步骤
组件的使用分成三个步骤：</li>
<li>创建组件构造器（调用Vue.extend())</li>
<li>注册组件(调用Vue.component())</li>
<li>使用组件。</li>
</ol>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1. 创建组件构造器对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnConstructor=Vue.extend(&#123;</span></span><br><span class="line">    template:</span><br><span class="line"><span class="handlebars"><span class="xml">      `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">         <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>content1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>content2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">//2. 注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;mycpn&#x27;</span>,cpnConstructor)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从而<code>&lt;div&gt;</code>就能显示东西了，并且这个组件可以到处复用（再次使用）</p>
<h2 id="每一步的含义"><a href="#每一步的含义" class="headerlink" title="每一步的含义"></a>每一步的含义</h2><h3 id="Vue-extend-："><a href="#Vue-extend-：" class="headerlink" title="Vue.extend()："></a>Vue.extend()：</h3><ol>
<li>调用Vue.extend()创建的是一个组件构造器。 </li>
<li>通常在创建组件构造器时，传入template代表我们自定义组件的模板。</li>
<li>该模板就是在使用到组件的地方，要显示的HTML代码。<h3 id="Vue-component-："><a href="#Vue-component-：" class="headerlink" title="Vue.component()："></a>Vue.component()：</h3></li>
</ol>
<ol>
<li>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。</li>
<li>所以需要传递两个参数：1、注册组件的标签名 2、组件构造器</li>
</ol>
<p>组件必须挂载在某个Vue实例下，否则它不会生效</p>
<h1 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h1><p>当我们通过调用Vue.component()注册组件时，组件的注册是<strong>全局</strong>的，这意味着该组件可以在任意Vue实例下使用。</p>
<p>如果我们注册的组件是挂载在某个特定实例中, 那么就是一个<strong>局部</strong>组件（使用Vue实例里的components属性<strong>注册</strong>，创建组件构造器和全局一样）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    component:&#123;</span><br><span class="line">      cpn: cpnConstructor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>cpn是注册组件的名字，cpnConstructor是组件构造器（名字任意）</p>
<h1 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC1=Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC2=Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>content2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">cpnC1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpnC1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn1: cpnC1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>cpn2是父组件，cpn1是子组件</p>
<p>在构造器1里注册构造器2的组件，可以使得构造器1的组件可以内嵌构造器2的组件。</p>
<p>但此时构造器2的组件只能在1的组件中使用，如果要在其他地方使用，则还需要在Vue实例里注册（成为全局组件），或者在其他构造器里注册（成为局部组件）</p>
<p>Vue实例也可以看作是一个组件（根组件）</p>
<h1 id="注册组件的语法糖写法"><a href="#注册组件的语法糖写法" class="headerlink" title="注册组件的语法糖写法"></a>注册组件的语法糖写法</h1><h2 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>,&#123;</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;title&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一个参数是组件的名字，第二个参数是构造器（直接在<code>.component()</code>中定义）</p>
<h2 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;cpn1&#x27;</span>:&#123;</span><br><span class="line">            template:</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h1><p>template里的内容过于繁杂，可以把HTML模块分离出去</p>
<h2 id="lt-script-type-quot-text-x-template-quot-gt-标签"><a href="#lt-script-type-quot-text-x-template-quot-gt-标签" class="headerlink" title="&lt;script type=&quot;text/x-template&quot;&gt;标签"></a><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;<span class="attr">template</span>: <span class="string">&#x27;#cpn&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：script标签里的id是用来和组件注册联系在一起的（<code>#cpn</code>)</p>
<h2 id="lt-template-gt-标签"><a href="#lt-template-gt-标签" class="headerlink" title="&lt;template&gt;标签"></a><code>&lt;template&gt;</code>标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;<span class="attr">template</span>: <span class="string">&#x27;#cpn&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的data属性"><a href="#组件的data属性" class="headerlink" title="组件的data属性"></a>组件的data属性</h1><p>上面的组件中，显示的内容都是写死的。现在我们希望组件当中的数据被一个变量代替，这样修改变量就可以自动修改组件显示的内容。</p>
<p>可以尝试，发现在Vue实例中定义一个变量<code>title= &#39;我是标题&#39;</code>，随后在组件里写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>会出现错误，即组件不能直接访问顶层Vue实例里的数据</p>
<p>组件对象也有一个<strong>data属性</strong>，这个data属性必须是一个<strong>函数</strong>，返回一个<strong>对象</strong>，对象内部保存着数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn1&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//等价于data: function()&#123; ... &#125;,data()是es6的新写法</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        title: <span class="string">&#x27;abc&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="data的methods属性"><a href="#data的methods属性" class="headerlink" title="data的methods属性"></a>data的methods属性</h2><p>以下用组件封装一个计数器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数：&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1. 注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        counter: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;<span class="built_in">this</span>.counter++;&#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;<span class="built_in">this</span>.counter--;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出，组件的methods属性类似于Vue实例的methods属性</p>
<p>此外，<code>&lt;div id=&quot;app&quot;&gt;</code>下放了两个组件，两个组件的数据<strong>互不干扰</strong>（即一个点了按钮，不会影响另一个的数据），这就实现了组件的<strong>复用</strong>（不同的模块都可以直接用<code>&lt;cpn&gt;</code>的形式调用组件，且不会相互影响）</p>
<p><strong>为什么不会相互影响？</strong><br>这就是data必须是函数的原因，不同的组件调用data里的函数，会返回不同的对象（即使data的内容相同）（可以类比C++的函数，不同的函数调用同一个子函数，不会相互干扰）</p>
<p><strong>如果一定要相互干扰呢？</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1. 注册组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> obj=&#123;<span class="attr">counter</span>: <span class="number">0</span>&#125; <span class="comment">//const的对象的属性可以修改，但是不能改变obj指向的对象</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> obj;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;<span class="built_in">this</span>.counter++;&#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;<span class="built_in">this</span>.counter--;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即定义一个全局变量</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Ch12 动态内存与智能指针</title>
    <url>/2021/04/01/c++/cpp-ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>静态内存</strong>：保存局部static变量、类static变量和在函数体外定义的变量<br><strong>栈内存</strong>：保存定义在函数体内的非static变量<br>分配在静态内存和栈内存中的对象由<font color="red">编译器自动创建或销毁</font>；栈对象仅在程序块运行时存在；static在程序结束时销毁</p>
<p>此外，每个程序还拥有一个内存池（堆内存）用于<font color="red">动态分配</font>的对象；这类对象的生存周期由程序控制，即需要代码显示销毁<br> <span id="more"></span></p>
<h1 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h1><p> <strong>动态内存</strong>的管理时通过<font color="red">运算符</font><code>new</code>和<code>delete</code>完成的，<code>new</code>在对象在动态内存中分配空间并返回一个指向该对象的指针，<code>delete</code>接受一个指向动态对象的指针并销毁该对象，释放关联的内存<br> 忘记释放内存就会造成<font color="red">内存泄漏</font></p>
<p> <strong>智能指针</strong>用于安全地使用动态内存，可以自动释放所指向的对象；<code>shared_ptr</code>允许多个指针指向同一个对象、<code>unqiue_ptr</code>独占指向的对象、<code>weak_ptr</code>是一种弱引用，指向<code>shared_ptr</code>管理的对象<br> 智能指针在头文件<code>&lt;memory&gt;</code>中</p>
<h2 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h2><p>shared_ptr是一个模板类，定义时要在尖括号里给出指向对象的类型</p>
<p><strong>shared_ptr与unqiue_ptr都支持的操作</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;   <span class="comment">//默认初始化，包含一个空指针</span></span><br><span class="line">unique_ptr&lt;T&gt; up;</span><br><span class="line">p;  <span class="comment">//用作条件判断，有指向的对象就为true</span></span><br><span class="line">*p;  <span class="comment">//解引用；</span></span><br><span class="line">p-&gt;mem;  </span><br><span class="line">p.<span class="built_in">get</span>();  <span class="comment">//返回p中保存的指针</span></span><br><span class="line"><span class="built_in">swap</span>(p,q);  <span class="comment">//交换包含的指针</span></span><br><span class="line">p.<span class="built_in">swap</span>(q);</span><br></pre></td></tr></table></figure>
<p><strong>shared_ptr独有的操作</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">make_shared&lt;T&gt;(args);  <span class="comment">//返回一个动态分配的、类型为T的对象的智能指针，对象用args初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q)</span></span>;  <span class="comment">//拷贝初始化，q中的计数器会递增。q中的指针必须能转换为T*</span></span><br><span class="line">p=q;  <span class="comment">//p与q都必须是shared_ptr,且保存的指针能相互转换。</span></span><br><span class="line">      <span class="comment">//此操作会递减p的计数器并递增q的计数器，如果p的计数器为0，则释放</span></span><br><span class="line">p.<span class="built_in">unqiue</span>();  <span class="comment">//若p.use_count() == 1，则返回true，否则false</span></span><br><span class="line">p.<span class="built_in">use_count</span>(); <span class="comment">//返回与p共享对象的智能指针数量，可能很慢</span></span><br></pre></td></tr></table></figure>
<h3 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h3><p>这是分配和使用动态内存最安全的方法，注意该函数也要<strong>传入创建对象的类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//make_shared&lt;T&gt;(args)</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; int_p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">//int_p指向值为42的int</span></span><br><span class="line">shared_ptr&lt;string&gt; str_p = make_shared&lt;string&gt;(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)  <span class="comment">//str_p指向值为&quot;aaa&quot;的字符串</span></span><br></pre></td></tr></table></figure>
<p>args即指向对象类型的构造函数参数列表，不传递参数则进行<strong>值初始化</strong></p>
<p>可以用auto定义一个对象保存<code>make_shared</code>的返回值</p>
<h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>进行拷贝和赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象<br>每个<code>shared_ptr</code>都有一个引用计数，当1) 用一个<code>shared_ptr</code>初始化另一个 2) 作为参数传递给函数 3) 作为函数的返回值 时，计数都会<strong>递增</strong>。当某个<code>shared_ptr</code>被赋予新值或者被销毁，计数就会<strong>递减</strong></p>
<h3 id="shared-ptr的自动销毁"><a href="#shared-ptr的自动销毁" class="headerlink" title="shared_ptr的自动销毁"></a>shared_ptr的自动销毁</h3><p>当指向对象的最后一个<code>shared_ptr</code>被销毁时（引用计数为0），<code>shared_ptr</code>类就会自动销毁此对象（通过调用<strong>析构函数</strong>）</p>
<p>对于一块内存，只要有一个<code>shared_ptr</code>对象引用它，该内存就不会被释放。如果<code>shared_ptr</code>无用且未销毁，则会浪费内存。</p>
<h3 id="程序为何使用动态内存？"><a href="#程序为何使用动态内存？" class="headerlink" title="程序为何使用动态内存？"></a>程序为何使用动态内存？</h3><p>a) 程序不知道自己要使用多少对象<br>b) 程序不知道自己所需对象的准确类型<br>c) 程序需要在多个对象间共享数据</p>
<h2 id="直接管理内存（new、delete）"><a href="#直接管理内存（new、delete）" class="headerlink" title="直接管理内存（new、delete）"></a>直接管理内存（new、delete）</h2><p>区别于智能指针，<code>new</code>和<code>delete</code>不能依赖对象的拷贝、赋值和销毁的默认定义，容易出错</p>
<h3 id="使用new动态分配和初始化对象"><a href="#使用new动态分配和初始化对象" class="headerlink" title="使用new动态分配和初始化对象"></a>使用new动态分配和初始化对象</h3><p>自由空间分配的内存是无名的，因而new无法为其分配的对象命名，而是返回一个指向该对象的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认情况下，动态分配的对象是默认初始化的</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; <span class="comment">//ps指向一个空串</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//pi指向一个未初始化的int</span></span><br><span class="line"><span class="comment">//可以用直接初始化或列表初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//指向一个值为&quot;aaaaa&quot;的字符串</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; </span><br><span class="line"><span class="comment">//也可以用值初始化,即加一对空括号</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p>对于有自己的构造函数的类型来说，值初始化没有意义；但对于<strong>内置类型</strong>，值初始化对内置类型有良好定义的值，而默认初始化对象的值则是无定义的</p>
<p>截至P408</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>动态内存</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基础语法3</title>
    <url>/2021/04/14/vue_js/Vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%953/</url>
    <content><![CDATA[<h1 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h1><p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。</p>
<ol>
<li>v-for的语法类似于JavaScript中的for循环。</li>
<li>格式如下：<code>v-for=&quot;item in items&quot;</code>的形式。<h2 id="v-for遍历数组"><a href="#v-for遍历数组" class="headerlink" title="v-for遍历数组"></a>v-for遍历数组</h2></li>
<li>如果在遍历的过程中不需要使用索引值<br><code>v-for=&quot;movie in movies&quot;</code>,依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie</li>
<li>如果在遍历的过程中，需要拿到元素在数组中的索引值:<br><code>v-for=(item, index) in items</code>,其中的index就代表了取出的item在原数组的索引值。<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--names: [&#x27;tom&#x27;,&#x27;jack&#x27;,&#x27;mary&#x27;,&#x27;bob&#x27;]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只需要输出数组元素--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;name in names&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--还需要索引值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(name,index) in names&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;.&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-for遍历对象"><a href="#v-for遍历对象" class="headerlink" title="v-for遍历对象"></a>v-for遍历对象</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只能得到value--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in info&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--获得键值对--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in info&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &lt;--获取键值对和index--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in info&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&gt; info:&#123;</span><br><span class="line">&gt;         name: &#x27;ywy144&#x27;,</span><br><span class="line">&gt;         age: 21,</span><br><span class="line">&gt;         height: 1.80</span><br><span class="line">&gt;       &#125;</span><br></pre></td></tr></table></figure>
注意value，key，index的顺序</li>
</ol>
<h2 id="组件的key属性"><a href="#组件的key属性" class="headerlink" title="组件的key属性"></a>组件的key属性</h2><p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。</p>
<p>为什么需要这个key属性？key的作用主要是为了高效的更新虚拟DOM，这和Vue的虚拟DOM的<strong>Diff算法</strong>有关系。</p>
<p>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点。</p>
<p>比如我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：把C更新成F，D更新成C，E更新成D，最后再插入E，很没有效率。</p>
<p>所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in letters&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：不能用<code>:key=&quot;index&quot;</code>，index与元素不一定一一对应</p>
<h2 id="数组中那些方法能支持响应式？"><a href="#数组中那些方法能支持响应式？" class="headerlink" title="数组中那些方法能支持响应式？"></a>数组中那些方法能支持响应式？</h2><p>支持响应式：<br><code>push() pop() shift() unshift() splice() sort() reverse()</code></p>
<p>直接修改数组元素是不支持响应式的：<code>arr[0]=111</code><br>需要使用<code>splice()</code>来完成支持响应式的替代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.splice(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>); <span class="comment">//下标为5的元素被替换为aaa</span></span><br></pre></td></tr></table></figure>
<p>也可以使用Vue的一个方法来完成，假设有一个Vue实例，里面有一个数组为arr：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue.set(要操作的元素，索引值，新值)</span></span><br><span class="line">Vue.set(<span class="built_in">this</span>.arr,<span class="number">5</span>,<span class="string">&#x27;aaaaa&#x27;</span>);  <span class="comment">//arr中下标为5的元素被替换为aaaaa</span></span><br></pre></td></tr></table></figure>
<h1 id="小案例-图书购物车"><a href="#小案例-图书购物车" class="headerlink" title="小案例-图书购物车"></a>小案例-图书购物车</h1><p>界面要求显示序号、书籍名称、出版日期、价格、购买数量、操作（移除）。购买数量的数字两边有+和-两个按钮，数量为0时显示购物车为空</p>
<h2 id="过滤器属性filters"><a href="#过滤器属性filters" class="headerlink" title="过滤器属性filters"></a>过滤器属性filters</h2><p>定义一个过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        nums: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">        <span class="function"><span class="title">numConvert</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num.toFixed(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用过滤器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;num in nums&quot;</span>&gt;</span>&#123;&#123;num | numConvert&#125;&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.00 2.00 3.00 4.00 5.00--&gt;</span></span><br></pre></td></tr></table></figure>
<p>过滤器会把<code>|</code>前的变量作为过滤器函数的第一个参数传入</p>
<h2 id="购物车实现"><a href="#购物车实现" class="headerlink" title="购物车实现"></a>购物车实现</h2><p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;list.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>书籍名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>出版日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>购买数量<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(book,index) in list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;book.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;book.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;book.date&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;book.price | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--注意increment和decrement的实现--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement(index)&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;book.count&lt;=1&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          &#123;&#123;book.count&#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment(index)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;removeBtn(index)&quot;</span>&gt;</span>移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>购物车为空<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">                name: <span class="string">&#x27;《算法导论》&#x27;</span>,</span><br><span class="line">                date: <span class="string">&#x27;2006-9&#x27;</span>,</span><br><span class="line">                price: <span class="number">85.00</span>,</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">2</span>,</span><br><span class="line">                name: <span class="string">&#x27;《UNIX编程艺术》&#x27;</span>,</span><br><span class="line">                date: <span class="string">&#x27;2006-2&#x27;</span>,</span><br><span class="line">                price: <span class="number">59.00</span>,</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">3</span>,</span><br><span class="line">                name: <span class="string">&#x27;《编程珠玑》&#x27;</span>,</span><br><span class="line">                date: <span class="string">&#x27;2008-10&#x27;</span>,</span><br><span class="line">                price: <span class="number">39.00</span>,</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">4</span>,</span><br><span class="line">                name: <span class="string">&#x27;《代码大全》&#x27;</span>,</span><br><span class="line">                date: <span class="string">&#x27;2006-3&#x27;</span>,</span><br><span class="line">                price: <span class="number">128.00</span>,</span><br><span class="line">                count: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">decrement</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.list[index].count--;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">increment</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.list[index].count++;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">removeBtn</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.list.splice(index,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">        <span class="function"><span class="title">showPrice</span>(<span class="params">price</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span>+price.toFixed(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="function"><span class="title">totalPrice</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> totalPrice=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.list.length;i++)</span><br><span class="line">                totalPrice+=<span class="built_in">this</span>.list[i].price*<span class="built_in">this</span>.list[i].count;</span><br><span class="line">            <span class="keyword">return</span> totalPrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>style.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span>,<span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f7f7f7</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5c6b77</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p>Vue中使用v-model指令来实现表单元素和数据的双向绑定。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，输入框内默认内容是message的值，并且输入框里的内容也会实时地赋给message</p>
<p>也可以绑定到textarea</p>
<p>如果不用v-model，怎么实现双向绑定？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;valueChange&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Vue实例里的methods--&gt;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">      valueChange(event)&#123;</span><br><span class="line">        this.message=event.target.value;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>或者更简单的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message=$event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-model实际上是一个<strong>语法糖</strong>，本质上就是两个操作的结合：</p>
<ol>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件</li>
</ol>
<h2 id="v-model结合radio"><a href="#v-model结合radio" class="headerlink" title="v-model结合radio"></a>v-model结合radio</h2><p>通过v-model获取用户选择选项的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name一致就能互斥--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      sex: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击男，<code>&lt;h2&gt;</code>就会显示男，反之选女</p>
<p>注意，如果两个radio的v-model绑定同一个变量，不写相同的name也能保证互斥</p>
<p>如果Vue实例里的sex变量默认为’男’，则会默认选中radio男</p>
<h2 id="v-model结合checkbox"><a href="#v-model结合checkbox" class="headerlink" title="v-model结合checkbox"></a>v-model结合checkbox</h2><ol>
<li>单个勾选框：<br>v-model即为<strong>布尔值</strong>。<br>此时input的value并不影响v-model的值。</li>
<li>多个复选框：<br>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个<strong>数组</strong>。<br>当选中某一个时，就会将input的value添加到数组中。</li>
</ol>
<h2 id="v-model结合select"><a href="#v-model结合select" class="headerlink" title="v-model结合select"></a>v-model结合select</h2><ol>
<li>单选：只能选中一个值。<br>v-model绑定的是<strong>一个值</strong>。<br>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</li>
<li>多选：可以选中多个值。<br>v-model绑定的是一个<strong>数组</strong>。<br>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</li>
</ol>
<p>单选是<code>&lt;select v-model=&quot;xxx&quot;&gt;</code><br>多选是<code>&lt;select v-model=&quot;xxx&quot; multiple&gt;</code></p>
<h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>即表单的默认值可以动态绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in hobbies&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从而实现了动态绑定，即后台数据里的hobbies变了，前端选项也会跟着变；选中的选项也会扔给hobby</p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ol>
<li>lazy修饰符：<br>默认情况下，v-model默认是在input事件中同步输入框的数据的。<br>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。<br>lazy修饰符可以让数据在失去焦点或者回车时才会更新：</li>
<li>number修饰符：<br>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。<br>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。<br>number修饰符可以让在输入框中输入的内容自动转成数字类型：</li>
<li>trim修饰符：<br>如果输入的内容首尾有很多空格，通常我们希望将其去除<br>trim修饰符可以过滤内容左右两边的空格</li>
</ol>
<p>用法：<code>v-model.lazy=&quot;xxx&quot;</code></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>v-for</tag>
        <tag>v-model</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件化开发-Slot</title>
    <url>/2021/04/21/vue_js/Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91-Slot/</url>
    <content><![CDATA[<p>组件的插槽：</p>
<ol>
<li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li>
<li>让使用者可以决定组件内部的一些内容到底展示什么。<span id="more"></span>
比如导航栏，不同页面的导航栏有共性（比如都有返回），也有不同点。每一类导航栏都写一个组件显得麻烦，从而可以用Slot</li>
</ol>
<p>如何封装合适呢？抽取共性，保留不同。（理解）</p>
<ol>
<li>最好的封装方式就是将<strong>共性抽取到组件中</strong>，将<strong>不同暴露为插槽</strong>。</li>
<li>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。</li>
<li>是搜索框，还是文字，还是菜单。由调用者自己来决定。</li>
</ol>
<h1 id="使用Slot"><a href="#使用Slot" class="headerlink" title="使用Slot"></a>使用Slot</h1><ol>
<li>在子组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为子组件开启一个插槽。</li>
<li>该插槽插入什么内容取决于父组件如何使用。</li>
</ol>
<p>比如有三个cpn，我们希望第一个显示按钮，后面两个不显示按钮<br>因而按钮是个不同点，不能写到模板里：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;cpn&gt;</code>标签里的东西会去替换模板里的<code>&lt;slot&gt;</code></p>
<p>也可以在<code>&lt;slot&gt;</code>写<strong>默认值</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样插槽的位置会默认摆一个按钮，如果<code>&lt;cpn&gt;</code>里有别的东西，再做替换</p>
<p>如果<code>&lt;cpn&gt;</code>标签里塞了一堆元素，则会一起去替换<code>&lt;slot&gt;</code></p>
<h1 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h1><p>有时候我们可能需要好几个插槽，那么就需要给slot命名:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;up&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;down&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>插槽3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，指定某个插槽被替换：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">slot</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就可以实现替换，插槽2被替换为哈哈哈</p>
<p>任意元素都可以互相替换，不一定要一致（比如不一定要h2换h2）</p>
<h1 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h1><p>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Vue实例与子组件里都定义了一个isShow，前一个是true，后一个是false</p>
<p>最终组件会显示，因为我们在使用<code>&lt;my-cpn v-show=&quot;isShow&quot;&gt;&lt;/my-cpn&gt;</code>的时候，整个组件的使用过程是相当于在父组件中出现的，因而会去父组件的作用域里找isShow（而不是子组件）</p>
<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><p>父组件替换插槽的标签，但是内容由子组件来提供。</p>
<p>先提一个需求：<br>子组件中包括一组数据，比如：<code>pLanguages: [&#39;JavaScript&#39;, &#39;Python&#39;, &#39;Swift&#39;, &#39;Go&#39;, &#39;C++&#39;]</code></p>
<ol>
<li>需要在多个界面进行展示：</li>
<li>某些界面是以水平方向一一展示的，</li>
<li>某些界面是以列表形式展示的，</li>
<li>某些界面直接展示一个数组</li>
</ol>
<p>内容在子组件，希望父组件告诉我们如何展示，利用slot作用域插槽就可以了</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Slot</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 模块化开发1</title>
    <url>/2021/04/25/vue_js/Vue-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<p>为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护。</p>
<p>但是这种维护方式，依然不能避免一些灾难性的问题，比如全局变量同名问题。</p>
<p>另外，这种代码的编写方式对js文件的依赖顺序几乎是强制性的。但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较困难的事情。</p>
<span id="more"></span>
<h1 id="使用模块解决变量重名"><a href="#使用模块解决变量重名" class="headerlink" title="使用模块解决变量重名"></a>使用模块解决变量重名</h1><p>我们可以使用将需要暴露到外面的变量，使用一个模块作为出口</p>
<ol>
<li>在匿名函数内部，定义一个对象。</li>
<li>给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)。</li>
<li>最后将这个对象返回，并且在外面使用了一个MoudleA接受。</li>
</ol>
<p>在包含了定义模块文件的文件中，我们只需要使用属于自己模块的属性和方法即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ModuleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">//在对象内部添加变量个方法</span></span><br><span class="line">    obj.flag=<span class="literal">true</span>;</span><br><span class="line">    obj.myFun = <span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//其他文件中使用模块</span></span><br><span class="line"><span class="keyword">if</span>(ModuleA.flag)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ModuleA.myFun(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ModuleA);</span><br></pre></td></tr></table></figure>
<p>这就是模块最基础的封装，事实上模块的封装还有很多高级的话题：</p>
<ol>
<li>但是我们这里就是要认识一下为什么需要模块，以及模块的原始雏形。</li>
<li>幸运的是，前端模块化开发已经有了很多既有的规范，以及对应的实现方案。</li>
</ol>
<p>常见的模块化规范：CommonJS、AMD、CMD，也有ES6的Modules</p>
<p><strong>模块化实际上就是把每一个js文件封闭起来，保证不会命名冲突</strong></p>
<h1 id="模块化的核心"><a href="#模块化的核心" class="headerlink" title="模块化的核心"></a>模块化的核心</h1><p>导出：比如上面例子中return了一个obj<br>导入：使用模块</p>
<h1 id="ES6模块的导入和导出"><a href="#ES6模块的导入和导出" class="headerlink" title="ES6模块的导入和导出"></a>ES6模块的导入和导出</h1><p>ES6新增了两个关键字<code>export</code>和<code>import</code></p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p><code>export</code>用于导出变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aaa.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bbb.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在html文件里直接调用这两个js文件，就会造成<strong>命名冲突</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果增加<code>type=&quot;module&quot;</code>，就不会存在命名冲突，因为<strong>单独的模块有单独的作用域</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;aaa.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;bbb.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Vue组件化开发2</title>
    <url>/2021/04/17/vue_js/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%912/</url>
    <content><![CDATA[<h1 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h1><p>子组件是不能引用父组件或者Vue实例的数据的。</p>
<p>但是，在开发中，往往一些数据确实需要从上层传递到下层：</p>
<ol>
<li>比如在一个页面中，我们从服务器请求到了很多的数据。</li>
<li>其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</li>
<li>这个时候，并不会让子组件再次发送一个网络请求，而是<strong>直接让大组件(父组件)将数据传递给小组件</strong>(子组件)。<span id="more"></span>
如何进行<strong>父子组件间的通信</strong>呢？Vue官方提到</li>
<li>通过props<strong>向子组件</strong>传递数据</li>
<li>通过事件<strong>向父组件</strong>发送消息</li>
</ol>
<p>在下面的代码中，直接将Vue实例当做父组件，并且其中包含子组件来简化代码。<br>真实的开发中，Vue实例和子组件的通信和父组件和子组件的通信过程是一样的。</p>
<h2 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h2><p>首先父组件是Vue实例，里面要传递的数据是languages和message，子组件在父组件里定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span><br><span class="line">      languages: [<span class="string">&#x27;c++&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;haskell&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn  <span class="comment">//增强写法，当键值名字一样的时候，可以简写，cpn在外部定义</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>子组件的cpn定义在Vue实例的外部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpn=&#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn1&#x27;</span>,</span><br><span class="line">    props: [<span class="string">&#x27;mylanguages&#x27;</span>,<span class="string">&#x27;mymessage&#x27;</span>],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>props</strong>选项用于父组件向子组件传递数据，props是一个<strong>数组</strong>（也可以是一个<strong>对象</strong>，用于设定传递值的类型），里面包含了一些变量的名字，这些变量用于接受父组件传来的数据</p>
<p>template的内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;mylanguages&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;mymessage&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-bind:mylanguages</span>=<span class="string">&quot;languages&quot;</span> <span class="attr">:mymessage</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用<strong>v-bind</strong>绑定父组件与子组件的数据，注意子组件提供用于接收数据的变量名字都是<strong>小写</strong>（可以看出这种方式很便于复用）</p>
<p>props是一个<strong>对象</strong>时，可以限定传递数据的类型（验证传递数据的类型）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    mylanguages: <span class="built_in">Array</span>,</span><br><span class="line">    mymseeage: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以设定一个默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    mymessage:&#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&#x27;aaaaaaa&#x27;</span></span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>required为true时表示这个值必须传，不然报错</p>
<p><strong>类型是数组或对象</strong>时，默认值必须是一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    mylanguages:&#123;</span><br><span class="line">        type: <span class="built_in">Array</span>;</span><br><span class="line">        <span class="function"><span class="title">default</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h2><p>自定义事件的流程：</p>
<ol>
<li>在子组件中，通过$emit()来触发事件。</li>
<li>在父组件中，通过v-on来监听子组件事件。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-on:itemclick</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick(item)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn= &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        categories: [</span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ccc&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家具&#x27;</span>&#125;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;itemclick&#x27;</span>,item);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      languages: [<span class="string">&#x27;c++&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;haskell&#x27;</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      cpn  <span class="comment">//增强写法，当键值名字一样的时候，可以简写，cpn在外部定义</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">cpnClick</span>(<span class="params">item</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;cpnClick&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子传父，子组件要在自己的methods里定义一个函数，这个函数发射一个事件，<code>this.$emit()</code>可以只传一个参数，也可以传多个参数，这个函数把参数<strong>传给父组件</strong></p>
<p>点击按钮，按钮触发子组件里的一个方法，这个方法把参数传给父组件。使用父组件的时候，用<code>v-on</code>绑定监听的方法，并且这个方法要监听子组件里传递参数的方法</p>
<h1 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h1><p>区别于父子组件通信，父子组件访问是直接调用其他组件的内容（比如一个方法）</p>
<ol>
<li>父组件访问子组件：使用<code>$children</code>或<code>$refs</code></li>
<li>子组件访问父组件：使用<code>$parent</code></li>
</ol>
<h2 id="children"><a href="#children" class="headerlink" title="$children"></a><code>$children</code></h2><p><code>this.$children</code>是一个数组类型，它包含所有子组件对象</p>
<p>比如有以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是子组件</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$children);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$children.length);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$children[<span class="number">0</span>].showMessage();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;showMessage&#x27;</span>);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设一个父组件有多个子组件，那么<code>this.$children[i]</code>表示第i+1个子组件，要使用该子组件里定义的数据、方法等即<code>this.$children[i].fun()</code>(比如一个fun方法)</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="$ref"></a><code>$ref</code></h2><p><code>$children</code>的缺陷：</p>
<ol>
<li>通过<code>$children</code>访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。</li>
<li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</li>
<li>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用<code>$refs</code></li>
</ol>
<p><code>$refs</code>的使用：</p>
<ol>
<li><code>$refs</code>和ref指令通常是一起使用的。</li>
<li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li>
<li>其次，通过<code>this.$refs.ID</code>就可以访问到该组件了。</li>
</ol>
<p><strong>注意，refs返回的是一个对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以下为父组件里的方法--&gt;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">      btnClick()&#123;</span><br><span class="line">        console.log(this.$refs.aaa);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>这样就可以直接访问<code>id=&quot;aaa&quot;</code>的子组件了</p>
<h2 id="parent"><a href="#parent" class="headerlink" title="$parent"></a><code>$parent</code></h2><p>不推荐使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是子组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击按钮，就会输出父组件里的messgae</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 数据类型</title>
    <url>/2021/04/03/javascript/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 的数据类型，共有六种。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>数值（number）</td>
<td>整数和小数（比如1和3.14）。</td>
</tr>
<tr>
<td>字符串（string）</td>
<td>文本（比如Hello World）。</td>
</tr>
<tr>
<td>布尔值（boolean）</td>
<td>表示真伪的两个特殊值，即true（真）和false（假）。</td>
</tr>
<tr>
<td>undefined</td>
<td>表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</td>
</tr>
<tr>
<td>null</td>
<td>表示空值，即此处的值为空。</td>
</tr>
<tr>
<td>对象（object）</td>
<td>各种值组成的集合。</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>数值、字符串、布尔值这三种类型，合称为<strong>原始类型</strong>（primitive type）的值，即它们是最基本的数据类型，不能再细分了。</p>
<p>对象则称为<strong>合成类型</strong>=的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的<strong>容器</strong>，对象可细分为狭义的对象（object）、数组（array）、函数（function）</p>
<p>至于undefined和null，一般将它们看成两个<strong>特殊值</strong>。</p>
<h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof运算符可以返回一个值的数据类型(一个<strong>字符串</strong>)</p>
<p>数值、字符串、布尔值分别返回number、string、boolean。<br>函数返回function<br>undefined返回undefined。利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对象和null返回object</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>空数组（[]）的类型也是object</strong>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。</p>
<h1 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null, undefined"></a>null, undefined</h1><p>null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，语法效果几乎没区别。<br>在if语句中，它们都会被自动转为false，相等运算符（==）直接报告两者相等。</p>
<h2 id="null-undefined用法与含义"><a href="#null-undefined用法与含义" class="headerlink" title="null,undefined用法与含义"></a>null,undefined用法与含义</h2><p>null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。</p>
<p>undefined表示“未定义”，下面是返回undefined的典型场景<br><font color="red">大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>下列运算符会返回布尔值：</p>
<ol>
<li>前置逻辑运算符： ! (Not)</li>
<li>相等运算符：===，!==，==，!=（===不转换类型，==转换类型再比较）</li>
<li>比较运算符：&gt;，&gt;=，&lt;，&lt;=</li>
<li>逻辑运算：&amp;&amp; ||</li>
</ol>
<p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true:</p>
<ol>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>0</li>
<li>NaN</li>
<li>“”或’’（空字符串）</li>
</ol>
<p>注意，<font color="red">空数组（[]）和空对象（{}）对应的布尔值，都是true</font></p>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="整数与浮点数"><a href="#整数与浮点数" class="headerlink" title="整数与浮点数"></a>整数与浮点数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p>
<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个<strong>阈值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>NaN</strong>这个特殊的Number与所有其他值都不相等，包括它自己。唯一能判断NaN的方法是通过isNaN()函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>根据IEEE754，绝对值小于2的53次方的<strong>整数</strong>，即-2^53 到2^53，都可以精确表示</p>
<p>简单的法则就是，JavaScript 对15位的十进制数都可以精确处理</p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p>
<p>如果一个数大于等于2的1024次方，那么就会发生“<strong>正向溢出</strong>”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity</p>
<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“<strong>负向溢出</strong>”，即 JavaScript 无法表示这么小的数，这时会直接返回0</p>
<p>JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>JavaScript的数组可以包括任意数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
<p>另一种<strong>创建数组</strong>的方法是通过Array()函数实现:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br></pre></td></tr></table></figure>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>要取得Array的长度，直接访问length属性</p>
<p>直接给Array的length<strong>赋一个新值</strong>会导致Array大小的变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="修改数组元素"><a href="#修改数组元素" class="headerlink" title="修改数组元素"></a>修改数组元素</h2><p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果通过索引赋值时，<strong>索引超过了范围</strong>，同样会引起Array大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>Array也可以通过indexOf()来<strong>搜索一个指定的元素的位置</strong>，不包含元素则返回-1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p>截取Array的部分元素，然后返回一个新的Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>如果不给slice()传递任何参数，它就会从头到尾截取所有元素,可以很容易地复制一个Array:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h2><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：<br><strong>注意</strong>：空数组继续pop不会报错，而是返回undefined</p>
<h2 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h2><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序,可以传入函数<strong>改变排序方式</strong></p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><p>反转数组</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素.<br><strong>前两个参数</strong>是删除的起始位置和删除元素的数目，<strong>随后</strong>是添加的元素，返回被删除的元素组成的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array</p>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<p>实际上，concat()方法可以接收<strong>任意个元素和Array</strong>，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>如果数组的某个元素又是一个Array，则可以形成多维数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>], <span class="string">&#x27;-&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>查找元素：arrname[pos1][pos2]…[posn]</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>JavaScript的字符串就是用’’或””括起来的字符表示。</p>
<p>如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p>
<p>如果字符串内部既包含’又包含”，可以用转义字符\来标识，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>要把多个字符串连接起来，可以用+号连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;你好, &#x27;</span> + name + <span class="string">&#x27;, 你今年&#x27;</span> + age + <span class="string">&#x27;岁了!&#x27;</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<h3 id="获取字符串某个指定位置的字符"><a href="#获取字符串某个指定位置的字符" class="headerlink" title="获取字符串某个指定位置的字符"></a>获取字符串某个指定位置的字符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// &#x27;w&#x27;</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// &#x27;!&#x27;</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>
<p>区别于数组，字符串是<font color="red">不可变的</font></p>
<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>toUpperCase()把一个字符串全部变为大写，toLowerCase()把一个字符串全部变为小写，不操作原串，有返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回&#x27;HELLO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回&#x27;hello&#x27;并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf()会搜索指定字符串出现的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span>;</span><br><span class="line">s.indexOf(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 返回7</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;World&#x27;</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>substring()返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回&#x27;hello&#x27;</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回&#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>JavaScript的对象是一种无序的<strong>集合</strong>数据类型，它由若干<strong>键值对</strong>组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.birth; <span class="comment">// 1990</span></span><br></pre></td></tr></table></figure>
<p>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含<strong>特殊字符</strong>，就必须用’’括起来,访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;No.1 Middle School&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问特殊属性</span></span><br><span class="line">xiaohong[<span class="string">&#x27;middle-school&#x27;</span>]; <span class="comment">// &#x27;No.1 Middle School&#x27;</span></span><br><span class="line"><span class="comment">//普通名字的属性，.和[]运算符都可行</span></span><br><span class="line">xiaohong[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// &#x27;小红&#x27;</span></span><br><span class="line">xiaohong.name; <span class="comment">// &#x27;小红&#x27;</span></span><br></pre></td></tr></table></figure>
<p>访问<strong>不存在的属性</strong>不会报错，而是返回undefined</p>
<h2 id="增加，删除属性"><a href="#增加，删除属性" class="headerlink" title="增加，删除属性"></a>增加，删除属性</h2><p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>
<h2 id="检测属性是否存在"><a href="#检测属性是否存在" class="headerlink" title="检测属性是否存在"></a>检测属性是否存在</h2><ol>
<li>如果我们要检测xiaoming是否拥有某一属性，可以用<strong>in操作符</strong>：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.1 Middle School&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming<strong>继承</strong>得到的：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</li>
<li>要判断一个属性是否是xiaoming<strong>自身拥有</strong>的，而不是继承得到的，可以用hasOwnProperty()方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 起步</title>
    <url>/2021/04/09/vue_js/Vue-%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="引入Vue"><a href="#引入Vue" class="headerlink" title="引入Vue"></a>引入Vue</h1><p>在<code>&lt;body&gt;</code>标签下引入Vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--src里的路径是vue.js的位置--&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><h2 id="普通文本展示"><a href="#普通文本展示" class="headerlink" title="普通文本展示"></a>普通文本展示</h2><p>每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;details()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">const</span> vm=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data:&#123;</span><br><span class="line"><span class="javascript">         message: <span class="string">&#x27;hello world!&#x27;</span>,</span></span><br><span class="line"><span class="javascript">         name: <span class="string">&#x27;ywy144&#x27;</span></span></span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">         details: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">return</span> <span class="built_in">this</span>.message+<span class="string">&#x27; &#x27;</span>+<span class="built_in">this</span>.name;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Vue实例的构造函数需要传入一个<strong>对象类型</strong>，该对象类型包括以下：</p>
<ol>
<li>构造函数Vue中有一个<strong>el</strong>，这指的是DOM元素中的id（即id匹配的元素与这个Vue实例绑定）。注意要以#开头</li>
<li><strong>data</strong>用于定义属性（实例中应包含的数据成员）</li>
<li><strong>methods</strong> 用于定义的成员函数，可以通过 return 来返回函数值。</li>
<li><code>&#123;&#123;&#125;&#125;`用于绑定数据，会自动根据id去绑定的Vue实例里找`&#123;&#123;&#125;&#125;</code>里的名字。<strong>注意</strong>：函数要记得添加<code>()</code><br><code>&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</code><br>两个大括号的写法被称为“Mustache”语法（文本插值），Mustache 标签将会被替代为对应数据对象上<code>msg</code> property的值。<strong>如果这个值被修改，对应元素的内容也会立马被修改</strong>（响应式/声明式）</li>
<li>倘若在Vue实例创建之后再添加数据成员，则这个数据成员不会参与响应式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">&#x27;ywy144&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.nation = <span class="string">&#x27;China&#x27;</span>;</span><br><span class="line"><span class="comment">//nation不会参与响应式</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="列表展示"><a href="#列表展示" class="headerlink" title="列表展示"></a>列表展示</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in languages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">         message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">         languages: [<span class="string">&#x27;c++&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;javascript&#x27;</span>]</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样可以展示一个列表，每一行都是languages里的一个元素</p>
<p>注意<code>&lt;li v-for=&quot;item in languages&gt;</code>，这种写法可以避免一个个写languages[i]。vue会自动循环，把language里的元素全部输出</p>
<h2 id="小案例-计数器"><a href="#小案例-计数器" class="headerlink" title="小案例-计数器"></a>小案例-计数器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数：&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--@click即v-on：click，表示需要监听的事件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;infoPrint&quot;</span>&gt;</span>+且有输出语句<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      infoPrint: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter++;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;按钮点击成功&#x27;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>@click等价于v-on:click，v-on表示监听事件</li>
<li>v-on绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</li>
</ol>
<h1 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h1><p>MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。</p>
<p>view是视图（DOM，呈现给用户），model可以理解为数据，viewModel就是处在当中的模块（Vue），具有数据绑定和监听DOM的作用</p>
<p>比如计数器的代码中，view是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数：&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--@click即v-on：click，表示需要监听的事件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;infoPrint&quot;</span>&gt;</span>+且有输出语句<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>model是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      counter: 0</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>让view和model联系起来，且视图和业务逻辑分开的任务是由定义的Vue实例（viewModel）完成的：</p>
<ol>
<li>数据绑定：vue实例将data中的counter绑定到<code>&lt;h2&gt;</code>中的，从而实时的在DOM中显示</li>
<li>DOM监听：<code>&lt;buttom&gt;</code>中定义的指令由vue解析，解析出的事件再回调到methods中，来改变model</li>
</ol>
<p>Vue可以帮我们完成viewModel层的任务，让我们聚焦于view和model的编写</p>
<h1 id="创建Vue实例传入的options"><a href="#创建Vue实例传入的options" class="headerlink" title="创建Vue实例传入的options"></a>创建Vue实例传入的options</h1><p>简单的有el，data，method</p>
<p><strong>el</strong>：string或者HTMLElement，决定之后Vue实例会管理哪个DOM</p>
<p><strong>data</strong>：object或者function（组件当中的data必须是函数），Vue实例对应的数据对象</p>
<p><strong>methods</strong>：{[key:string]:function}，定义一些方法，可以在其他地方调用，也可以在指令里使用（都是匿名函数，通过属性调用）</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>对象从诞生到消亡的整个过程<br><img src="https://cn.vuejs.org/images/lifecycle.png" width="80%"></p>
<p>在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数（在执行到生命周期的某个步骤的时候来回调函数），这给了用户在不同阶段添加自己的代码的机会。</p>
<ol>
<li><strong>beforeCreate钩子</strong>：用来在一个实例被<strong>创建之前</strong>执行代码</li>
<li><strong>created钩子</strong>：用来在一个实例被<strong>创建之后</strong>执行代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a is: &#x27;</span> + <span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;a is: 1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>beforeMounted钩子</strong>：</li>
<li><strong>mounted钩子</strong>：</li>
<li><strong>beforeUpdated钩子</strong>：</li>
<li><strong>updated钩子</strong>：</li>
<li><strong>beforeDestroyed钩子</strong>：</li>
<li><strong>destroyed钩子</strong>：</li>
</ol>
<p><strong>注意</strong>：<br>不要在选项 property 或回调上使用箭头函数，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。<br>因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue实例</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数2</title>
    <url>/2021/04/05/javascript/Javascript-%E5%87%BD%E6%95%B02/</url>
    <content><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在一个对象中绑定函数，称为这个对象的<strong>方法</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></span><br><span class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个<strong>this关键字</strong>:<br>在一个方法内部，this是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。</p>
<p>如果拆开写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>可见，成员函数必须以方法的形式调用，单独调用时，this的指向是全局变量window</p>
<p>如果这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>也是错误的，为了保证this的指向正确，必须以方法的形式调用函数</p>
<p>如果在对象内部的函数里又定义了一个函数，最内部的函数的this不会指向对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>修复办法：<strong>使用that变量捕获this</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>要<strong>指定函数的this指向哪个对象</strong>，可以用<strong>函数本身</strong>的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure>

<p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<ol>
<li>apply()把参数打包成Array再传入；</li>
<li>call()把参数按顺序传入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把this绑定为null。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;30&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;count = &#x27;</span> + count); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>注意，javascript是可以直接返回函数的（函数也是对象）</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map()是array的一个方法，接受一个函数fun()，对数组中的所有元素执行fun()并返回一个新数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>
<p>把Array的所有数字转为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">arr.map(<span class="built_in">String</span>); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span></span><br><span class="line"><span class="comment">//String()，数字变字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须<strong>接收两个参数</strong>，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。</p>
<p>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure>

<p>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element); <span class="comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 依次打印0, 1, 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(self); <span class="comment">// self就是变量arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>利用filter，可以巧妙地去除Array的重复元素,去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    r,</span><br><span class="line">    arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index; <span class="comment">//apple,strawberry,banana,pear,orange</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>这是因为Array的sort()方法<strong>默认把所有元素先转换为String再排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure>

<p>sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，我们可以这么写：（默认升序）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">//[1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure>
<p>sort()方法会直接对Array进行修改，它返回的结果仍是当前Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = a1.sort();</span><br><span class="line">a1; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a2; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Array提供的其他高阶函数"><a href="#Array提供的其他高阶函数" class="headerlink" title="Array提供的其他高阶函数"></a>Array提供的其他高阶函数</h2><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>every()方法可以判断数组的所有元素是否满足测试条件。</p>
<p>都满足则返回true，否则返回false</p>
<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined</p>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p>findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值.</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数3</title>
    <url>/2021/04/06/javascript/Javascript-%E5%87%BD%E6%95%B03/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</span></span><br><span class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></span><br><span class="line"><span class="comment">//调用函数f时，才真正计算求和的结果：</span></span><br><span class="line">f(); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包”的程序结构拥有极大的威力。</p>
<p>当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数</p>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//局部变量i在作祟</span></span><br><span class="line">f1(); <span class="comment">// 16</span></span><br><span class="line">f2(); <span class="comment">// 16</span></span><br><span class="line">f3(); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results = count();</span><br><span class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 1</span></span><br><span class="line">f2(); <span class="comment">// 4</span></span><br><span class="line">f3(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>注意这里用了一个“<strong>创建一个匿名函数并立刻执行</strong>”的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p>
<p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = initial || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            x += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> c1 = create_counter();</span><br><span class="line">c1.inc(); <span class="comment">// 1</span></span><br><span class="line">c1.inc(); <span class="comment">// 2</span></span><br><span class="line">c1.inc(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p><strong>闭包就相当于，你在某一局游戏里身上加的BUFF被你带到了下一局游戏里，所以说威力巨大</strong><br><strong>闭包是内部函数可以访问外部函数的变量，反之亦然</strong></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x =&gt; x * x</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于<strong>匿名函数</strong>，并且简化了函数定义。</p>
<p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数不是一个，就需要用括号()括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyntaxError:</span></span><br><span class="line">x =&gt; &#123; <span class="attr">foo</span>: x &#125;</span><br><span class="line"><span class="comment">//正确写法：</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。</p>
<p>箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="built_in">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>generator跟函数很像，定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由function*定义，并且，除了return语句，还可以用yield返回多次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接<strong>调用一个generator</strong>和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。</p>
<p>调用generator对象有两个方法:</p>
<ol>
<li><strong>不断地调用generator对象的next()方法</strong>：<br>next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</span><br><span class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>第二个方法是直接用<strong>for … of循环迭代generator对象</strong>，这种方式不需要我们自己判断done<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        t,</span><br><span class="line">        a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>,</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1, 2, 3, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器2</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A82/</url>
    <content><![CDATA[<h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p>
<p>注意：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。</p>
<span id="more"></span>
<p>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p>
<p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对<strong>文件扩展名做检查</strong>（.endsWith)，以便防止用户上传无效格式的文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-file-upload&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.value; <span class="comment">// &#x27;C:\fakepath\test.png&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (!filename || !(filename.endsWith(<span class="string">&#x27;.jpg&#x27;</span>) || filename.endsWith(<span class="string">&#x27;.png&#x27;</span>) || filename.endsWith(<span class="string">&#x27;.gif&#x27;</span>))) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;Can only upload image file.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>HTML5新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p>
<p>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p>
<p>下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-image-file&#x27;</span>),</span><br><span class="line">    info = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-file-info&#x27;</span>),</span><br><span class="line">    preview = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-image-preview&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听change事件:</span></span><br><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除背景图片:</span></span><br><span class="line">    preview.style.backgroundImage = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">    <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">        info.innerHTML = <span class="string">&#x27;没有选择文件&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取File引用:</span></span><br><span class="line">    <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取File信息:</span></span><br><span class="line">    info.innerHTML = <span class="string">&#x27;文件: &#x27;</span> + file.name + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;大小: &#x27;</span> + file.size + <span class="string">&#x27;&lt;br&gt;&#x27;</span> +</span><br><span class="line">                     <span class="string">&#x27;修改: &#x27;</span> + file.lastModifiedDate;</span><br><span class="line">    <span class="keyword">if</span> (file.type !== <span class="string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.type !== <span class="string">&#x27;image/png&#x27;</span> &amp;&amp; file.type !== <span class="string">&#x27;image/gif&#x27;</span>) &#123;</span><br><span class="line">        alert(<span class="string">&#x27;不是有效的图片文件!&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件:</span></span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span></span><br><span class="line">            data = e.target.result; <span class="comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span></span><br><span class="line">        preview.style.backgroundImage = <span class="string">&#x27;url(&#x27;</span> + data + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以DataURL的形式读取文件:</span></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p>
<p>在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reader.readAsDataURL(file);</span><br></pre></td></tr></table></figure>
<p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当文件读取完成后，自动调用此函数:</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。</p>
<p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p>
<p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p>
<p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p>
<p>需要注意：AJAX请求是异步执行的，也就是说，<strong>要通过回调函数获得响应</strong>。</p>
<p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = <span class="string">&#x27;Error code: &#x27;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/categories&#x27;</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;请求已发送，请等待响应...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。</p>
<p>XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。</p>
<p>注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</p>
<p>最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。</p>
<h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p>上面代码的URL使用的是<strong>相对路径</strong>。如果你把它改为’<a href="http://www.sina.com.cn/&#39;%EF%BC%8C%E5%86%8D%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%82%AF%E5%AE%9A%E6%8A%A5%E9%94%99%E3%80%82">http://www.sina.com.cn/&#39;，再运行，肯定报错。</a></p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同（<a href="http://www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。">www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</a></p>
<p>如何突破这个限制，请求外域（就是其他网站）的URL？通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/proxy?url=http://www.sina.com.cn&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<a href="http://my.com,或者是*,本次请求就可以成功./">http://my.com，或者是*，本次请求就可以成功。</a></p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p>
<p>上面这种跨域请求，称之为“<strong>简单请求</strong>”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: <span class="string">&#x27;FontAwesome&#x27;</span>;</span><br><span class="line">  src: url(<span class="string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) format(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 简介</title>
    <url>/2021/04/03/javascript/Javascript-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="什么是Javascript？"><a href="#什么是Javascript？" class="headerlink" title="什么是Javascript？"></a>什么是Javascript？</h1><p>JavaScript 是一种轻量级的脚本语言。所谓“<strong>脚本语言</strong>”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。</p>
<p>JavaScript 是一种嵌入式语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O相关的 API，都要靠宿主环境提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p>
<span id="more"></span>
<p>目前，已经嵌入 JavaScript 的<strong>宿主环境</strong>有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p>
<p>从语法角度看，JavaScript语言是一种“<strong>对象模型</strong>”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如<strong>函数式编程</strong>）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。</p>
<p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类：</p>
<ol>
<li>浏览器控制类：操作浏览器</li>
<li>DOM 类：操作网页的各种元素</li>
<li>Web 类：实现互联网的各种功能</li>
</ol>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript JQuery1</title>
    <url>/2021/04/09/javascript/Javascript-JQuery1/</url>
    <content><![CDATA[<p>JavaScript世界中使用最广泛的一个库。</p>
<p>jQuery能帮我们干这些事情：</p>
<ol>
<li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li>
<li>简洁的操作DOM的方法：写$(‘#test’)肯定比document.getElementById(‘test’)来得简洁；</li>
<li>轻松实现动画、修改CSS等各种操作。<span id="more"></span>
使用JQuery:<br>使用jQuery只需要在页面的<code>&lt;head&gt;</code>引入jQuery文件即可：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h1><p>jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p>$本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>选择器是jQuery的核心。一个选择器写出来类似<code>$(&#39;#dom-id&#39;)</code>。</p>
<p>相对于之前DOM操作中的繁琐代码，JQuery选择器可以帮助我们快速定位到一个或多个DOM节点。</p>
<h2 id="普通选择器"><a href="#普通选择器" class="headerlink" title="普通选择器"></a>普通选择器</h2><h3 id="按ID查找"><a href="#按ID查找" class="headerlink" title="按ID查找"></a>按ID查找</h3><p>如果某个DOM节点有id属性，利用jQuery查找如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id=&quot;abc&quot;&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#abc&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，#abc以#开头。返回的对象是jQuery对象。</p>
<p>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
<p>以上面的查找为例，如果id为abc的<code>&lt;div&gt;</code>存在，返回的jQuery对象如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>]</span><br></pre></td></tr></table></figure>
<p>如果id为abc的<code>&lt;div&gt;</code>不存在，返回的jQuery对象如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>总之jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。</p>
<p>jQuery对象和DOM对象之间可以互相转化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#abc&#x27;</span>); <span class="comment">// jQuery对象</span></span><br><span class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></span><br><span class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// 重新把DOM包装为jQuery对象</span></span><br></pre></td></tr></table></figure>
<h3 id="按tag查找"><a href="#按tag查找" class="headerlink" title="按tag查找"></a>按tag查找</h3><p>按tag查找只需要写上tag名称就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">&#x27;p&#x27;</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br></pre></td></tr></table></figure>
<h3 id="按class查找"><a href="#按class查找" class="headerlink" title="按class查找"></a>按class查找</h3><p>按class查找注意在class名称前加一个.：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 所有节点包含`class=&quot;red&quot;`都将返回</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常很多节点有多个class，我们可以查找同时包含red和green的节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;.red.green&#x27;</span>); <span class="comment">// 注意没有空格！</span></span><br><span class="line"><span class="comment">// 符合条件的节点：</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red green&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;blue green red&quot;&gt;...&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="按属性查找"><a href="#按属性查找" class="headerlink" title="按属性查找"></a>按属性查找</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> email = $(<span class="string">&#x27;[name=email]&#x27;</span>); <span class="comment">// 找出&lt;??? name=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">&#x27;[type=password]&#x27;</span>); <span class="comment">// 找出&lt;??? type=&quot;password&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;[items=&quot;A B&quot;]&#x27;</span>); <span class="comment">// 找出&lt;??? items=&quot;A B&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用<strong>前缀查找</strong>或者<strong>后缀查找</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">&#x27;[name^=icon]&#x27;</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">&#x27;[name$=with]&#x27;</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">&#x27;[class^=&quot;icon-&quot;]&#x27;</span>); <span class="comment">// 找出所有class包含至少一个以`icon-`开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: class=&quot;icon-clock&quot;, class=&quot;abc icon-home&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="组合查找"><a href="#组合查找" class="headerlink" title="组合查找"></a>组合查找</h3><p>如果我们查找<code>$(&#39;[name=email]&#39;)</code>，很可能把表单外的<code>&lt;div name=&quot;email&quot;&gt;</code>也找出来，但我们只希望查找<code>&lt;input&gt;</code>，就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">&#x27;input[name=email]&#x27;</span>); <span class="comment">// 不会找出&lt;div name=&quot;email&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样的，根据tag和class来组合查找也很常见：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tr = $(<span class="string">&#x27;tr.red&#x27;</span>); <span class="comment">// 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多项选择器"><a href="#多项选择器" class="headerlink" title="多项选择器"></a>多项选择器</h3><p>多项选择器就是把多个选择器用,组合起来一块选：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;p,div&#x27;</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></span><br><span class="line">$(<span class="string">&#x27;p.red,p.green&#x27;</span>); <span class="comment">// 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。</p>
<h2 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h2><p>如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;testing&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;lang&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-javascript&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-python&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;lang-lua&quot;</span>&gt;</span>Lua<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要选出JavaScript，可以用层级选择器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li.lang-javascript&#x27;</span>); <span class="comment">// [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">&#x27;div.testing li.lang-javascript&#x27;</span>); <span class="comment">// [&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br></pre></td></tr></table></figure>
<p>要选择所有的<code>&lt;li&gt;</code>节点，用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>多层选择也是允许的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;form.test p input&#x27;</span>); <span class="comment">// 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>子选择器<code>$(&#39;parent&gt;child&#39;)</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang&gt;li.lang-javascript&#x27;</span>); <span class="comment">// 可以选出[&lt;li class=&quot;lang-javascript&quot;&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">&#x27;div.testing&gt;li.lang-javascript&#x27;</span>); <span class="comment">// [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 选出JavaScript、Python和Lua 3个节点</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:first-child&#x27;</span>); <span class="comment">// 仅选出JavaScript</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:last-child&#x27;</span>); <span class="comment">// 仅选出Lua</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(2)&#x27;</span>); <span class="comment">// 选出第N个元素，N从1开始</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(even)&#x27;</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">&#x27;ul.lang li:nth-child(odd)&#x27;</span>); <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h3><p>针对表单元素，jQuery还有一组特殊的选择器：</p>
<p>:input：可以选择<code>&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt;</code>；</p>
<p>:file：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，和input<code>[type=file]</code>一样；</p>
<p>:checkbox：可以选择复选框，和input<code>[type=checkbox]</code>一样；</p>
<p>:radio：可以选择单选框，和input<code>[type=radio]</code>一样；</p>
<p>:focus：可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用$(‘input:focus’)就可以选出；</p>
<p>:checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</p>
<p>:enabled：可以选择可以正常输入的<code>&lt;input&gt;、&lt;select&gt;</code> 等，也就是没有灰掉的输入；</p>
<p>:disabled：和:enabled正好相反，选择那些不能输入的。</p>
<p>此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div:visible&#x27;</span>); <span class="comment">// 所有可见的div</span></span><br><span class="line">$(<span class="string">&#x27;div:hidden&#x27;</span>); <span class="comment">// 所有隐藏的div</span></span><br></pre></td></tr></table></figure>
<h2 id="查找和过滤"><a href="#查找和过滤" class="headerlink" title="查找和过滤"></a>查找和过滤</h2><p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。例如如下的HTML结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;lang&quot;</span>&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;js dy&quot;</span>&gt;JavaScript&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dy&quot;</span>&gt;Python&lt;/li&gt;</span><br><span class="line">    &lt;li id=<span class="string">&quot;swift&quot;</span>&gt;Swift&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dy&quot;</span>&gt;Scheme&lt;/li&gt;</span><br><span class="line">    &lt;li name=<span class="string">&quot;haskell&quot;</span>&gt;Haskell&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>用<code>find()</code>查找：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">&#x27;ul.lang&#x27;</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">&#x27;#swift&#x27;</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">&#x27;[name=haskell]&#x27;</span>); <span class="comment">// 获得Haskell</span></span><br></pre></td></tr></table></figure>
<p>如果要从当前节点开始向上查找，使用<code>parent()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">&#x27;#swift&#x27;</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</span></span><br></pre></td></tr></table></figure>
<p>对于位于同一层级的节点，可以通过<code>next()</code>和<code>prev()</code>方法，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">&#x27;#swift&#x27;</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">&#x27;[name=haskell]&#x27;</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// Python，因为Python同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p><code>filter()</code>方法可以过滤掉不符合选择器条件的节点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">&#x27;ul.lang li&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">&#x27;.dy&#x27;</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 标准对象</title>
    <url>/2021/04/07/javascript/Javascript-%E6%A0%87%E5%87%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h1><p>number、boolean和string都有包装对象，可以包装成<strong>object类型</strong>。包装对象用new创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">// &#x27;str&#x27;,生成了新的包装类型</span></span><br></pre></td></tr></table></figure>
<p>虽然包装对象看上去和原来的值一模一样,但他们的类型已经变为object了。所以，包装对象和原始值用===比较会返回false</p>
<span id="more"></span>
<p>如果我们在使用Number、Boolean和String时<strong>没有写new</strong>，三个函数会被当做普通函数，把任何类型的数据转换为number、boolean和string类型</p>
<p>需要遵守的规则：</p>
<ol>
<li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li>
<li>用parseInt()或parseFloat()来转换任意类型到number；</li>
<li>用String()来<strong>转换任意类型到string</strong>，或者直接调用<strong>某个对象的toString()方法</strong>；</li>
<li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li>
<li>typeof操作符可以判断出number、boolean、string、function和undefined；</li>
<li>**判断Array要使用Array.isArray(arr)**；</li>
<li><strong>判断null请使用myVar === null</strong>；</li>
<li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li>
<li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li>
</ol>
<p>对于3中的tostring()方法，对象null和undefined不具有这个方法</p>
<p>对number类型调用tostring()也会报错，要使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123.</span>.toString(); <span class="comment">// &#x27;123&#x27;, 注意是两个点！</span></span><br><span class="line">(<span class="number">123</span>).toString(); <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>在JavaScript中，Date对象用来表示日期和时间。</p>
<p>要获取<strong>系统当前时间</strong>，用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure>

<p>如果要<strong>创建</strong>一个指定日期和时间的Date对象，可以用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月</strong>。</p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>.parse(<span class="string">&#x27;2015-06-24T19:49:22.875+08:00&#x27;</span>);</span><br><span class="line">d; <span class="comment">// 1435146562875</span></span><br></pre></td></tr></table></figure>
<p>但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Date.parse()时传入的字符串使用实际月份01<del>12，转换为Date对象后getMonth()获取的月份值为0</del>11</strong>。</p>
<h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。</p>
<p>JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>和JavaScript的number完全一致</td>
</tr>
<tr>
<td>boolean</td>
<td>就是JavaScript的true或false</td>
</tr>
<tr>
<td>string</td>
<td>就是JavaScript的string</td>
</tr>
<tr>
<td>null</td>
<td>就是JavaScript的null</td>
</tr>
<tr>
<td>array</td>
<td>就是JavaScript的Array表示方式——[]</td>
</tr>
<tr>
<td>object</td>
<td>就是JavaScript的{ … }表示方式</td>
</tr>
</tbody></table>
<p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p>
<p>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;</span></span><br></pre></td></tr></table></figure>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 14,</span></span><br><span class="line"><span class="comment">  &quot;gender&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;height&quot;: 1.65,</span></span><br><span class="line"><span class="comment">  &quot;grade&quot;: null,</span></span><br><span class="line"><span class="comment">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; Middle School&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JavaScript&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Java&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Python&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Lisp&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;skills&#x27;</span>], <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JavaScript&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Java&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Python&quot;,</span></span><br><span class="line"><span class="comment">    &quot;Lisp&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">&#x27;  &#x27;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;name&quot;: &quot;小明&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: 14,</span></span><br><span class="line"><span class="comment">  &quot;gender&quot;: true,</span></span><br><span class="line"><span class="comment">  &quot;height&quot;: 1.65,</span></span><br><span class="line"><span class="comment">  &quot;grade&quot;: null,</span></span><br><span class="line"><span class="comment">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; MIDDLE SCHOOL&quot;,</span></span><br><span class="line"><span class="comment">  &quot;skills&quot;: [</span></span><br><span class="line"><span class="comment">    &quot;JAVASCRIPT&quot;,</span></span><br><span class="line"><span class="comment">    &quot;JAVA&quot;,</span></span><br><span class="line"><span class="comment">    &quot;PYTHON&quot;,</span></span><br><span class="line"><span class="comment">    &quot;LISP&quot;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>JSON.parse()还可以接收一个函数，用来转换解析出的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>标准对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 基本语法</title>
    <url>/2021/04/03/javascript/Javascript-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内</p>
<p>语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值</p>
<span id="more"></span>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>变量的声明与赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果只声明未赋值，则变量是<strong>未定义的</strong>(undefined)</p>
<p>使用一个未声明的变量，则会报错</p>
<p>可以同时声明多个变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript 是一种<strong>动态类型</strong>语言，也就是说，<strong>变量的类型没有限制</strong>，变量可以随时更改类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用var重新声明一个已经存在的变量是无效的，如果再次声明且赋值，则会覆盖原值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">//无效，x仍为1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;<span class="comment">//x为2</span></span><br></pre></td></tr></table></figure>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做<strong>变量提升</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//a未定义</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ol>
<li>&amp;&amp;</li>
<li>1两边条件都为true时，结果才为true；</li>
<li>2如果有一个为false，结果就为false；</li>
<li>3当第一个条件为false时，就不再判断后面的条件</li>
</ol>
<p>注意：当数值参与逻辑与运算时，结果为true，那么会返回的会是第二个为真的值；如果结果为false，返回的会是第一个为假的值。</p>
<ol start="2">
<li>||</li>
<li>1只要有一个条件为true时，结果就为true；</li>
<li>2当两个条件都为false时，结果才为false；</li>
<li>3当一个条件为true时，后面的条件不再判断</li>
</ol>
<p>注意：当数值参与逻辑或运算时，结果为true，会返回第一个为真的值；如果结果为false，会返回第二个为假的值；</p>
<ol start="3">
<li>！</li>
<li>1当条件为false时，结果为true；反之亦然。</li>
</ol>
<p>补充：逻辑与的优先级是高于逻辑或的；</p>
<p>比如console.log(3||2&amp;&amp;5||0),会先算2&amp;&amp;5的值为5，然后再3||5—-3，最后再3||0—-3，所以最终结果为3.</p>
<p><strong>补充</strong></p>
<p><code>表达式a &amp;&amp; 表达式b </code>:  计算表达式a（也可以是函数）的运算结果，<br>                      如果为 True, 执行表达式b（或函数），并返回b的结果；<br>                      如果为 False，返回a的结果；</p>
<p><code>表达式a || 表达式b </code>:   计算表达式a（也可以是函数）的运算结果，<br>                      如果为 Fasle, 执行表达式b（或函数），并返回b的结果；<br>                      如果为 True，返回a的结果；</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符指的是用来识别各种值的合法名称。最常见的标识符就是<strong>变量名</strong>和<strong>函数名</strong>。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。</p>
<p>命名规则：</p>
<ol>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9</li>
</ol>
<p>JavaScript 有一些<strong>保留字</strong>，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>用//或/**/包起来的行或数行</p>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><p>大括号包围起来的代码块，对于var命令来说，JavaScript 的区块不构成单独的作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值) <span class="comment">//括号里可以是值为布尔值的表达式</span></span><br><span class="line">  语句;</span><br></pre></td></tr></table></figure>
<h2 id="if-else-if结构"><a href="#if-else-if结构" class="headerlink" title="if else if结构"></a>if else if结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔值)</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(布尔值)</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不加break，则之后的每个条件都会判定<br>switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时<strong>不会发生类型转换</strong>。</p>
<h2 id="三运运算符"><a href="#三运运算符" class="headerlink" title="三运运算符:?"></a>三运运算符:?</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式)&#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>break语句用于跳出代码块或循环<br>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环</p>
<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置<br>标签通常与break语句和continue语句配合使用，跳出特定的循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label:  <span class="comment">//label可以是任意的名字（不包括保留字）</span></span><br><span class="line">  语句</span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;i=&#x27;</span> + i + <span class="string">&#x27;, j=&#x27;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 函数1</title>
    <url>/2021/04/04/javascript/Javascript-%E5%87%BD%E6%95%B01/</url>
    <content><![CDATA[<h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li>function指出这是一个函数定义；</li>
<li>abs是函数的名称；</li>
<li>(x)括号内列出函数的参数，多个参数以,分隔；</li>
<li>{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ol>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是<strong>结果为undefined</strong>。</p>
<p>由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以<strong>视为指向该函数的变量</strong>。</p>
<p>从而，第二种定义函数的方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种方式下，function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。</p>
<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>调用函数时，按顺序传入参数即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
<p>传入的参数比定义的<strong>少</strong>也没有问题,此时abs(x)函数的参数x将收到undefined，计算结果为NaN:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(); <span class="comment">// 返回NaN</span></span><br></pre></td></tr></table></figure>
<p>要避免收到undefined，可以<strong>对参数进行检查</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>关键字arguments，它只在<strong>函数内部</strong>起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">/*x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 30*/</span></span><br></pre></td></tr></table></figure>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>如果传入的参数大于函数需要的参数，获取多余的参数可以用rest<br>注意，rest必须写在最后，并且形式为…rest</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<p>传入的参数先绑定a、b，多余的参数以数组形式交给变量rest</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;rest.length;i++)</span><br><span class="line">       sum=sum+rest[i];</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line"> &#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);  <span class="comment">//输出55</span></span><br></pre></td></tr></table></figure>
<p>如果传入的参数连正常定义的参数都没填满，rest参数会接收一个空数组（注意不是undefined）。</p>
<h2 id="小心return语句"><a href="#小心return语句" class="headerlink" title="小心return语句"></a>小心return语句</h2><p>JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拆成两行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际变成了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于return undefined;</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的多行写法是</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量作用域与解构赋值"><a href="#变量作用域与解构赋值" class="headerlink" title="变量作用域与解构赋值"></a>变量作用域与解构赋值</h1><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>
<ol>
<li>如果一个变量在<strong>函数体内部</strong>声明，则该变量的作用域为整个函数体，在函数体外不可引用该变量</li>
<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">1</span>; <span class="comment">// bar可以访问foo的变量x!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> z = y + <span class="number">1</span>; <span class="comment">// ReferenceError! foo不可以访问bar的变量y!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果内部函数和外部函数的变量名<strong>重名</strong>,则内部函数屏蔽外部定义的变量，不影响外部定义的变量</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部，<font color="red">但不会提升变量的赋值</font></p>
<p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，<strong>请严格遵守“在函数内部首先申明所有变量”这一规则</strong>。最常见的做法是用一个var申明函数内部用到的所有变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">        x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></span><br><span class="line">        y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></span><br><span class="line">        z, i; <span class="comment">// z和i为undefined</span></span><br><span class="line">    <span class="comment">// 其他语句:</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<strong>window</strong>，全局作用域的变量实际上被绑定到window的一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">&#x27;Learn JavaScript&#x27;</span>;</span><br><span class="line">alert(course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br><span class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// &#x27;Learn JavaScript&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，<strong>顶层函数的定义也被视为一个全局变量</strong>，并绑定到window对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 直接调用foo()</span></span><br><span class="line"><span class="built_in">window</span>.foo(); <span class="comment">// 通过window.foo()调用</span></span><br></pre></td></tr></table></figure>
<p>我们每次直接调用的alert()函数其实也是window的一个变量</p>
<p>这说明JavaScript实际上<strong>只有一个全局作用域</strong>。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<strong>ReferenceError</strong>错误。</p>
<h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数<strong>全部绑定到一个全局变量中</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">&#x27;myapp&#x27;</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决块级作用域，ES6引入了新的<strong>关键字let</strong>，用let替代var可以申明一个块级作用域的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：const指向的对象不能修改，但是对象内部的属性可以修改（内存问题）</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>从ES6开始，JavaScript引入了解构赋值，可以<strong>同时对一组变量进行赋值</strong>。</p>
<ol>
<li>多个变量同时赋值：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br><span class="line"><span class="comment">// x, y, z分别被赋值为数组对应元素:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x + <span class="string">&#x27;, y = &#x27;</span> + y + <span class="string">&#x27;, z = &#x27;</span> + z);</span><br><span class="line"><span class="comment">//x = hello, y = JavaScript, z = ES6</span></span><br></pre></td></tr></table></figure></li>
<li>数组元素进行解构赋值，多个变量要用[…]括起来:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">&#x27;hello&#x27;</span>, [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]];</span><br><span class="line">x; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">y; <span class="comment">// &#x27;JavaScript&#x27;</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure>
解构赋值还可以<strong>忽略</strong>某些元素：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>]; <span class="comment">// 忽略前两个元素，只对z赋值第三个元素</span></span><br><span class="line">z; <span class="comment">// &#x27;ES6&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br><span class="line"><span class="comment">//name = 小明, age = 20, passport = G-12345678</span></span><br></pre></td></tr></table></figure>
对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">        street: <span class="string">&#x27;No.1 Road&#x27;</span>,</span><br><span class="line">        zipcode: <span class="string">&#x27;100001&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">city; <span class="comment">// &#x27;Beijing&#x27;</span></span><br><span class="line">zip; <span class="comment">// undefined, 因为属性名是zipcode而不是zip</span></span><br><span class="line"><span class="comment">// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:</span></span><br><span class="line">address; <span class="comment">// Uncaught ReferenceError: address is not defined</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。</p>
<p>如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span>,</span><br><span class="line">    school: <span class="string">&#x27;No.4 middle school&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性赋值给变量id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">id; <span class="comment">// &#x27;G-12345678&#x27;</span></span><br><span class="line"><span class="comment">// 注意: passport不是变量，而是为了让变量id获得passport属性:</span></span><br><span class="line">passport; <span class="comment">// Uncaught ReferenceError: passport is not defined</span></span><br></pre></td></tr></table></figure>

<p>解构赋值还可以使用<strong>默认值</strong>，这样就避免了不存在的属性返回undefined的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    passport: <span class="string">&#x27;G-12345678&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">single; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量:</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br></pre></td></tr></table></figure>
<p>这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure>
<h3 id="快速获取当前页面的域名和路径："><a href="#快速获取当前页面的域名和路径：" class="headerlink" title="快速获取当前页面的域名和路径："></a>快速获取当前页面的域名和路径：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器3</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A83/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise：ES6中新提供的一个内置类(提到类可以想到new、原型、原型链、实例…)，基于promise可以有效的管理JS中的异步编程，解决传统异步编程+回调函数导致的‘回调地狱’问题。<br>Promise：承诺未来一定会执行</p>
<span id="more"></span>
<h2 id="Promise需要掌握的内容"><a href="#Promise需要掌握的内容" class="headerlink" title="Promise需要掌握的内容"></a>Promise需要掌握的内容</h2><p>从函数有三个角色入手：普通函数、构造函数（类）、普通对象</p>
<p>【普通对象 =&gt; 静态的私有属性方法】<br>promise.all()<br>promise.race()<br>promise.resolve()<br>promise.reject()</p>
<p>【类 =&gt; 原型链上的公共属性和方法】<br>promise.prototype.then()<br>promise.prototype.catch()<br>promise.prototype.finally() [一般不用]<br>【new创建实例】</p>
<h2 id="创建Promise实例"><a href="#创建Promise实例" class="headerlink" title="创建Promise实例"></a>创建Promise实例</h2><p>语法： <code>let 实例 = new Promise([executor])</code></p>
<p>我们在创建一个Promise的实例，需要给Promise传递一个函数，这个函数会立即执行，并且浏览器给它自带两个参数（两个参数也都是函数），这两个参数会改变Promise的状态和值</p>
<p><strong>说明</strong>：</p>
<ol>
<li>必须传一个函数,否则会报错：Uncaught TypeError: Promise resolver undefined is not a function</li>
<li>[executor]是一个函数，我们一般在函数中管控我们的异步编程代码</li>
<li>new Promise的时候就会把executor立即执行</li>
<li>并且给executor函数传递两个实参（两个实参也都是函数）：resolve/reject</li>
</ol>
<h2 id="Promise的两个值"><a href="#Promise的两个值" class="headerlink" title="Promise的两个值"></a>Promise的两个值</h2><h3 id="PromiseStatus"><a href="#PromiseStatus" class="headerlink" title="PromiseStatus"></a>PromiseStatus</h3><p>promise状态（要么是成功态要么是失败态）</p>
<ol>
<li>准备状态pending：new Promise的时候默认状态就是pending</li>
<li>成功状态fulfilled/resolved：一般在异步操作成功后，我们通过执行resolved函数，可以把promise的状态改为resolved</li>
<li>失败状态rejected：一般在异步操作失败后，我们通过执行reject函数，可以把promise的状态改为rejected</li>
</ol>
<p>pending =&gt; resolved / rejected 只要状态一旦更改，则不可以再改变</p>
<h3 id="PromiseValue"><a href="#PromiseValue" class="headerlink" title="PromiseValue"></a>PromiseValue</h3><p>promise的值</p>
<p>不论执行resolve/reject哪个函数，都可以传递值，传递的值最后赋值给PromiseValue</p>
<h2 id="Promise原型链上的公共方法—then"><a href="#Promise原型链上的公共方法—then" class="headerlink" title="Promise原型链上的公共方法—then"></a>Promise原型链上的公共方法—then</h2><p>我们在创建实例的时候可以修改Promise的状态，目的就是为了控制then中的两个方法，哪一个去执行。</p>
<p>then方法：<code>实例.then([状态成功时执行的]，[状态失败时执行的])</code><br>方括号里的是result函数和reason函数</p>
<p>result / reason 接收的是PromiseValue的信息（在executor函数中，基于resolve/reject执行传递的值，就是给promise-value传递的值，并且只能传递一个值，传递第二个实参没用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      reject(<span class="string">&#x27;NO&#x27;</span>);  <span class="comment">//reject的值可以传给PromiseValue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;OK&#x27;</span>);  <span class="comment">//resolve的值可以传给PromiseValue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`成功：<span class="subst">$&#123;result&#125;</span>`</span>); </span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`失败：<span class="subst">$&#123;reason&#125;</span>`</span>); <span class="comment">//当上面的随机是小于0.5的时候执行reject，也就是把状态改为失败态，从而执行then中的reason这个方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="什么时候执行then？"><a href="#什么时候执行then？" class="headerlink" title="什么时候执行then？"></a>什么时候执行then？</h3><ol>
<li><p> 创建实例时执行的是异步代码：<br>异步请求放置在EXECUTOR中，请求成功或者失败后做啥事情都写在THEN中</p>
</li>
<li><p>创建实例时执行的不是异步代码：</p>
</li>
</ol>
<p>–&gt;EXECUTOR函数中理论上是管控异步编程代码的，但是在开发中，你可以自己随意处理；但是不论怎么处理，THEN中的方法，只会在PROMISE状态变为成功或者失败的状态下才会执行；<br>–&gt;在EXECUTOR函数中执行RESOLVE或者REJECT，并不一定会立即通知THEN中的方法执行；如果在这两个函数执行之前，已经基于THEN把成功或者失败的方法放置好了，则立即通知执行；如果还没有执行过THEN方法，则需要等到THEN执行后，方法放置好，再通知成功或者失败的方法执行！</p>
<h3 id="then的返回值"><a href="#then的返回值" class="headerlink" title="then的返回值"></a>then的返回值</h3><p>每一次执行.then都会返回一个新的Promise实例（初始状态：pending初值：undefined）。这样可以继续.then下去，这就是Promise中的then链机制</p>
<p>下面的例子说明：<br>p2这个实例的成功或者失败状态，是由p1.then这堆代码决定的</p>
<p><strong>第一种情况</strong>：只要p1.then中不论哪个方法执行，只要不报错，新的p2实例的状态都会变为成功态，而方法返回的结果就是p2实例的promise-value值（也就是上一个then执行的返回结果，会传递给下一个then中的方法）；同理，两个方法中，不管哪一个执行报错，P2一定是失败态<br><strong>第二种情况</strong>：如果p1.then中的某个方法执行，返回的是新的Promise实例，则会等待这个Promise的执行结果，作为p2的执行状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;NO&#x27;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;  </span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;  </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = p2.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">//=&gt;&#x27;OK@@&#x27;</span></span><br><span class="line">  <span class="comment">// return Promise.resolve(100); //=&gt;P3的状态变为成功，值是100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="number">0</span>); <span class="comment">//=&gt;P3的状态变为失败，值是0</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span> + result);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>Promise.all([PROMISE1,PROMISE2,…])：等待所有的PROMISE实例都成功，整体才是成功的（返回新的PROMISE实例），只要有一个实例是失败的，整体实例就是失败的；</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race() 同时发送多个请求，谁先有处理结果（不管结果是成功还是失败），就以谁的结果为主（哪怕是失败的）</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>在项目中，我们会用<code> CATCH(REASON=&gt;&#123;&#125;)</code>代替<code> THEN(NULL,REASON=&gt;&#123;&#125;)</code>，效果是一模一样的（执行CATCH也会返回新的PROMISE实例，里面设置的方法是在实例为失败状态下执行的）</p>
<p>=&gt;在项目中，我们一般THEN中放的是成功执行的，CATCH中放的是失败执行的</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>比如下面的代码：我们输出一个从来没有定义过的变量，会报错，下面的代码也不再执行，但是我们想让下面的代码继续执行，就需要用到try catch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">//=&gt;Uncaught ReferenceError: n is not defined 浏览器抛出异常信息，下面代码就不会再执行了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>try</strong>：把可能会报错的代码放置到try中捕获异常（代码执行一但报错，控制台是不抛出异常的，不会影响后续代码的执行）<br><strong>catch</strong>：catch中捕获到异常信息 （可以把信息上报给服务器）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 把可能会报错的代码放置到TRY中捕获异常（代码执行一但报错，控制台是不抛出异常的，不会影响后续代码的执行）</span></span><br><span class="line"> <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"> <span class="comment">// CATCH中捕获到异常信息 （可以把信息上报给服务器）</span></span><br><span class="line"> <span class="comment">// console.log(error);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面<strong>绘制各种图表、动画等</strong>。</p>
<p>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>
<p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;test-canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>getContext(&#39;2d&#39;)</code>方法让我们拿到一个<code>CanvasRenderingContext2D</code>对象，所有的<strong>绘图操作</strong>都需要通过这个对象完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>绘制3D则有一个WebGL规范：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gl = canvas.getContext(<span class="string">&quot;webgl&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h2><p>Canvas的<strong>坐标</strong>以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>
<p><code>CanvasRenderingContext2D</code>对象有若干方法来绘制图形：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-shape-canvas&#x27;</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>); <span class="comment">// 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明</span></span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;#dddddd&#x27;</span>; <span class="comment">// 设置颜色</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">130</span>, <span class="number">130</span>); <span class="comment">// 把(10,10)位置大小为130x130的矩形涂色</span></span><br><span class="line"><span class="comment">// 利用Path绘制复杂路径:</span></span><br><span class="line"><span class="keyword">var</span> path=<span class="keyword">new</span> Path2D();</span><br><span class="line">path.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">path.moveTo(<span class="number">110</span>,<span class="number">75</span>);</span><br><span class="line">path.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">path.moveTo(<span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line">path.arc(<span class="number">60</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">path.moveTo(<span class="number">95</span>, <span class="number">65</span>);</span><br><span class="line">path.arc(<span class="number">90</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">ctx.strokeStyle = <span class="string">&#x27;#0000ff&#x27;</span>;</span><br><span class="line">ctx.stroke(path);</span><br></pre></td></tr></table></figure>
<h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-text-canvas&#x27;</span>),</span><br><span class="line">    ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">ctx.shadowOffsetX = <span class="number">2</span>;</span><br><span class="line">ctx.shadowOffsetY = <span class="number">2</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">2</span>;</span><br><span class="line">ctx.shadowColor = <span class="string">&#x27;#666666&#x27;</span>;</span><br><span class="line">ctx.font = <span class="string">&#x27;24px Arial&#x27;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;#333333&#x27;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&#x27;带阴影的文字&#x27;</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础1</title>
    <url>/2021/04/01/html/html-%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="html标题"><a href="#html标题" class="headerlink" title="html标题"></a>html标题</h1><p>HTML 标题（Heading）是通过<code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签来定义的<br><strong>例子</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="html段落"><a href="#html段落" class="headerlink" title="html段落"></a>html段落</h1><p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的</p>
<p>在一个段落标签里换行：<code>&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;</code></p>
<p>当显示页面时，浏览器会移除源代码中多余的空格和空行。<strong>所有连续的空格或空行都会被算作一个空格</strong>。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。</p>
<h1 id="html链接"><a href="#html链接" class="headerlink" title="html链接"></a>html链接</h1><p>HTML 链接是通过标签 <code>&lt;a&gt;</code> 来定义的<br><strong>例子</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 href 属性中指定链接的地址</p>
<h1 id="html图像"><a href="#html图像" class="headerlink" title="html图像"></a>html图像</h1><p>HTML 图像是通过标签 <code>&lt;img&gt;</code> 来定义的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>图像的名称和尺寸是以属性的形式提供的</p>
<h1 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h1><p>起始标签、标签内容和闭合标签构成一个<strong>html元素</strong>，html文档由html元素定义</p>
<p>html允许<strong>元素嵌套</strong></p>
<p><code>&lt;body&gt;</code> 元素定义了 HTML 文档的主体</p>
<p>HTML 标签对大小写不敏感</p>
<h1 id="html属性"><a href="#html属性" class="headerlink" title="html属性"></a>html属性</h1><p>属性可以在元素中添加附加信息<br>属性一般描述于开始标签<br>属性总是以名称/值对的形式出现，比如：name=”value”</p>
<p>属性值应该始终被包括在引号内。<br>双引号是最常用的，不过使用单引号也没有问题。<br>在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=’John “ShotGun” Nelson’</p>
<h1 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h1><p>格式：<code>&lt;!-- 这是一个注释 --&gt;</code></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础3</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<h1 id="html-CSS"><a href="#html-CSS" class="headerlink" title="html CSS"></a>html CSS</h1><p>通过使用 HTML4.0，所有的格式化代码均可移出 HTML 文档，然后移入一个独立的样式表。</p>
<span id="more"></span>
<h2 id="如何使用样式"><a href="#如何使用样式" class="headerlink" title="如何使用样式"></a>如何使用样式</h2><p>当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化。<br>有以下三种方式来插入样式表：</p>
<h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>使用外部样式表，可以通过更改一个文件来改变整个站点的外观。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。<br>可以在 head 部分通过 <code>&lt;style&gt;</code> 标签定义内部样式表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式<br>使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; margin-left: 20px&quot;</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="html表格"><a href="#html表格" class="headerlink" title="html表格"></a>html表格</h1><p>表格由 <code>&lt;table&gt;</code> 标签来定义。每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干单元格（由 <code>&lt;td&gt;</code> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示：</p>
<table border="1">
<tr>
<td>row 1, cell 1</td>
<td>row 1, cell 2</td>
</tr>
<tr>
<td>row 2, cell 1</td>
<td>row 2, cell 2</td>
</tr>
</table>

<h2 id="表格的边框属性"><a href="#表格的边框属性" class="headerlink" title="表格的边框属性"></a>表格的边框属性</h2><p>如果不定义边框属性，表格将不显示边框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="表格的表头"><a href="#表格的表头" class="headerlink" title="表格的表头"></a>表格的表头</h2><p>表格的表头使用 th标签进行定义。<br>大多数浏览器会把表头显示为粗体居中的文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="空单元格"><a href="#空单元格" class="headerlink" title="空单元格"></a>空单元格</h2><p>如果某个单元格是空的（没有内容），浏览器可能无法显示出这个单元格的边框<br>为了避免这种情况，在空单元格中添加一个<strong>空格占位符</strong>，就可以将边框显示出来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="comment">&lt;!--空格占位符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="html列表"><a href="#html列表" class="headerlink" title="html列表"></a>html列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>此列项目使用粗体圆点（典型的小黑圆圈）进行标记<br>无序列表始于 <code>&lt;ul&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>列表项目使用数字进行标记<br>有序列表始于 <code>&lt;ol&gt;</code> 标签。每个列表项始于 <code>&lt;li&gt;</code> 标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>自定义列表以 <code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code> 开始</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<dl>
<dt>Coffee</dt>
<dd>Black hot drink</dd>
<dt>Milk</dt>
<dd>White cold drink</dd>
</dl>

<h1 id="html-块"><a href="#html-块" class="headerlink" title="html 块"></a>html 块</h1><h2 id="html块元素"><a href="#html块元素" class="headerlink" title="html块元素"></a>html块元素</h2><p>块级元素在浏览器显示时，<strong>通常会以新行来开始（和结束）</strong>，例如<code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;table&gt;</code></p>
<h3 id="html-div"><a href="#html-div" class="headerlink" title="html div"></a>html div</h3><p><code>&lt;div&gt;</code> 可定义文档中的分区或节（division/section）。</p>
<p><code>&lt;div&gt;</code> 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。</p>
<p>如果用 id 或 class 来标记 <code>&lt;div&gt;</code>，那么该标签的作用会变得更加有效。</p>
<h2 id="html-内联元素"><a href="#html-内联元素" class="headerlink" title="html 内联元素"></a>html 内联元素</h2><p>内联元素在显示时通常不会以新行开始，例如<code>&lt;b&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code></p>
<h3 id="html-span"><a href="#html-span" class="headerlink" title="html span"></a>html span</h3><p>HTML <code>&lt;span&gt;</code> 元素是内联元素，可用作文本的容器。</p>
<p><code>&lt;span&gt;</code> 元素也没有特定的含义。</p>
<p>当与 CSS 一同使用时，<code>&lt;span&gt;</code> 元素可用于为部分文本设置样式属性。</p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript Map与Set</title>
    <url>/2021/04/04/javascript/Javascript-Map%E4%B8%8ESet/</url>
    <content><![CDATA[<p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。</p>
<p>但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p>
<p>从而引入了Map</p>
<span id="more"></span>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是一组键值对的结构，具有极快的查找速度，无论这个表有多大，查找速度都不会变慢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个空Map。</p>
<p>Map具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 是否存在key &#x27;Adam&#x27;: true</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 删除key &#x27;Adam&#x27;</span></span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">&#x27;Adam&#x27;</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在Set中<strong>自动被过滤</strong></p>
<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果</p>
<p>通过delete(key)方法可以删除元素</p>
<h1 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h1><p>ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。</p>
<p>具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ar a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">&#x27;=&#x27;</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用iterable内置的forEach方法，它<strong>接收一个函数</strong>，每次迭代就自动回调该函数。以<strong>Array</strong>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">&#x27;, index = &#x27;</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//A, index = 0</span></span><br><span class="line"><span class="comment">//B, index = 1</span></span><br><span class="line"><span class="comment">//C, index = 2</span></span><br></pre></td></tr></table></figure>
<p><strong>Set</strong>与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Map</strong>的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程</title>
    <url>/2021/04/07/javascript/Javascript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> robot = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.6</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>于是我们把它改名为Student，然后创建出xiaoming：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br></pre></td></tr></table></figure>
<p>注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br></pre></td></tr></table></figure>
<p>xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用</p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>如果你把xiaoming的原型指向其他对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bird = &#123;</span><br><span class="line">    fly: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is flying...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Bird;</span><br></pre></td></tr></table></figure>
<p>现在xiaoming已经无法run()了，他已经变成了一只鸟</p>
<p>在JavaScrip代码运行时期，你可以把xiaoming从Student变成Bird，或者变成任何对象。</p>
<p><strong>在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型</strong>.</p>
<p><strong>Object.create()方法</strong>可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 原型对象:</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    <span class="comment">// 初始化新对象:</span></span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p>
<p>例如，创建一个<strong>Array</strong>对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//其原型链是：</span></span><br><span class="line"><span class="comment">//arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</span></span><br></pre></td></tr></table></figure>
<p>Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。</p>
<p>当我们创建一个<strong>函数</strong>时,函数也是一个对象，它的原型链是：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。</p>
<p>如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要<strong>注意不要把原型链搞得太长</strong>。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>除了直接用{ … }<strong>创建一个对象外</strong>，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<strong>new</strong>调用这个函数，就可以创建一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.hello(); <span class="comment">// Hello, 小明!</span></span><br></pre></td></tr></table></figure>
<p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，<strong>它绑定的this指向新创建的对象</strong>，<strong>并默认返回this</strong>，也就是说，不需要在最后写return this;。</p>
<p>我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;匿名&#x27;</span>; <span class="comment">// 默认值为&#x27;匿名&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.prototype指向xiaoming的原型对象</span></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">xiaoming.grade; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">new</span> PrimaryStudent() ----&gt;</span> P<span class="function"><span class="title">rimaryStudent</span>.prototype ----&gt;</span> O<span class="function"><span class="title">bject</span>.prototype ----&gt;</span> null</span><br></pre></td></tr></table></figure>
<p>如果你想用最简单粗暴的方法这么干：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PrimaryStudent.prototype = Student.prototype;</span><br></pre></td></tr></table></figure>
<p>是不行的。这样使得PrimaryStudent和Student共享一个原型对象，定义PrimaryStudent则无意义。</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。中间对象可以用一个<strong>空函数F</strong>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个inherits()函数可以复用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = props.name || <span class="string">&#x27;Unnamed&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现原型继承链:</span></span><br><span class="line">inherits(PrimaryStudent, Student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>上面一种实现继承的缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p>
<p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Student</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用新的class关键字来编写Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个Student对象代码和前面章节完全一样</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.hello();</span><br></pre></td></tr></table></figure>
<h2 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h2><p>用class定义对象的另一个巨大的好处是继承更方便了。</p>
<p>原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, grade</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础5</title>
    <url>/2021/04/03/html/html-%E5%9F%BA%E7%A1%805/</url>
    <content><![CDATA[<h1 id="HTML-头部元素"><a href="#HTML-头部元素" class="headerlink" title="HTML 头部元素"></a>HTML 头部元素</h1><h2 id="HTML-lt-head-gt-元素"><a href="#HTML-lt-head-gt-元素" class="headerlink" title="HTML &lt;head&gt; 元素"></a>HTML <code>&lt;head&gt;</code> 元素</h2><p>head 元素是所有头部元素的容器。</p>
<p>以下标签都可以添加到 head 部分：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code> 以及 <code>&lt;style&gt;</code></p>
<span id="more"></span>
<h2 id="HTML-title-元素"><a href="#HTML-title-元素" class="headerlink" title="HTML title  元素"></a>HTML title  元素</h2><p>title 标签定义文档的标题。<br>title 元素能够：定义浏览器工具栏中的标题;提供页面被添加到收藏夹时显示的标题;显示在搜索引擎结果中的页面标题</p>
<h2 id="HTML-base-元素"><a href="#HTML-base-元素" class="headerlink" title="HTML base 元素"></a>HTML base 元素</h2><p>base 标签为页面上的所有链接规定默认地址或默认目标（target）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn/images/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML-link-元素"><a href="#HTML-link-元素" class="headerlink" title="HTML link 元素"></a>HTML link 元素</h2><p>link 标签定义文档与外部资源之间的关系。</p>
<p>link 标签最常用于连接样式表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HTML-style-元素"><a href="#HTML-style-元素" class="headerlink" title="HTML style 元素"></a>HTML style 元素</h2><p>style 标签用于为 HTML 文档定义样式信息。</p>
<p>您可以在 style 元素内规定 HTML 元素在浏览器中呈现的样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTML-meta-元素"><a href="#HTML-meta-元素" class="headerlink" title="HTML meta 元素"></a>HTML meta 元素</h2><p>meta 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。</p>
<p>典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据</p>
<p>一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下面的 meta 元素定义页面的描述--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Free Web tutorials on HTML, CSS, XML&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--下面的 meta 元素定义页面的关键词--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, XML&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTML-script-元素"><a href="#HTML-script-元素" class="headerlink" title="HTML script 元素"></a>HTML script 元素</h2><p>script 标签用于定义客户端脚本，比如 JavaScript</p>
<h1 id="HTML-布局"><a href="#HTML-布局" class="headerlink" title="HTML 布局"></a>HTML 布局</h1><h2 id="使用-div-元素的-HTML-布局"><a href="#使用-div-元素的-HTML-布局" class="headerlink" title="使用 div 元素的 HTML 布局"></a>使用 div 元素的 HTML 布局</h2><p>div 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位</p>
<h2 id="使用-HTML5-的网站布局"><a href="#使用-HTML5-的网站布局" class="headerlink" title="使用 HTML5 的网站布局"></a>使用 HTML5 的网站布局</h2><p>HTML5 提供的新语义元素定义了网页的不同部分：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>定义文档或节的页眉</td>
</tr>
<tr>
<td>nav</td>
<td>定义导航链接的容器</td>
</tr>
<tr>
<td>section</td>
<td>定义文档中的节</td>
</tr>
<tr>
<td>article</td>
<td>定义独立的自包含文章</td>
</tr>
<tr>
<td>aside</td>
<td>定义内容之外的内容（比如侧栏）</td>
</tr>
<tr>
<td>footer</td>
<td>定义文档或节的页脚</td>
</tr>
<tr>
<td>details</td>
<td>定义额外的细节</td>
</tr>
<tr>
<td>summary</td>
<td>定义 details 元素的标题</td>
</tr>
</tbody></table>
<h2 id="使用表格的-HTML-布局"><a href="#使用表格的-HTML-布局" class="headerlink" title="使用表格的 HTML 布局"></a>使用表格的 HTML 布局</h2><p>table 元素不是作为布局工具而设计的。</p>
<p>table 元素的作用是显示表格化的数据。</p>
<p>使用 table 元素能够取得布局效果，因为能够通过 CSS 设置表格元素的样式</p>
<h1 id="HTML-响应式设计"><a href="#HTML-响应式设计" class="headerlink" title="HTML 响应式设计"></a>HTML 响应式设计</h1><p>响应式设计RWD能够以可变尺寸传递网页，对于平板和移动设备是必需的</p>
<h2 id="使用-Bootstrap"><a href="#使用-Bootstrap" class="headerlink" title="使用 Bootstrap"></a>使用 Bootstrap</h2><p>使用现成的 CSS 框架。</p>
<p>Bootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jumbotron&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>W3School Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Resize this responsive page!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>London is the capital city of England.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It is the most populous city in the United Kingdom,</span><br><span class="line">    with a metropolitan area of over 13 million inhabitants.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Paris<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paris is the capital and most populous city of France.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Tokyo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">    and the most populous metropolitan area in the world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础2</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h1><h2 id="html-文本格式化标签"><a href="#html-文本格式化标签" class="headerlink" title="html 文本格式化标签"></a>html 文本格式化标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>定义粗体文本</td>
</tr>
<tr>
<td>em</td>
<td>定义着重文字</td>
</tr>
<tr>
<td>i</td>
<td>定义斜体字</td>
</tr>
<tr>
<td>small</td>
<td>定义小号字</td>
</tr>
<tr>
<td>strong</td>
<td>定义加重语气</td>
</tr>
<tr>
<td>sub</td>
<td>定义下标字</td>
</tr>
<tr>
<td>sup</td>
<td>定义上标字</td>
</tr>
<tr>
<td>ins</td>
<td>定义插入字</td>
</tr>
<tr>
<td>del</td>
<td>定义删除字</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>通常标签 <code>&lt;strong&gt;</code> 替换加粗标签 <code>&lt;b&gt;</code> 来使用, <code>&lt;em&gt;</code> 替换 <code>&lt;i&gt;</code>标签使用。</p>
<h2 id="html-“计算机输出”-标签"><a href="#html-“计算机输出”-标签" class="headerlink" title="html “计算机输出” 标签"></a>html “计算机输出” 标签</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>定义计算机代码</td>
</tr>
<tr>
<td>kbd</td>
<td>定义键盘码</td>
</tr>
<tr>
<td>samp</td>
<td>定义计算机代码样本</td>
</tr>
<tr>
<td>var</td>
<td>定义变量</td>
</tr>
<tr>
<td>pre</td>
<td>定义预格式文本</td>
</tr>
</tbody></table>
<h1 id="html链接"><a href="#html链接" class="headerlink" title="html链接"></a>html链接</h1><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p>
<p>在标签<code>&lt;a&gt;</code> 中使用了href属性来描述链接的地址</p>
<h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>//格式<br><code>&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt;</code><br>//例子<br><code>&lt;a href=&quot;https://www.runoob.com/&quot;&gt;访问菜鸟教程&lt;/a&gt;</code></p>
<h2 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h2><p>使用 target 属性定义被链接的文档在何处显示</p>
<p>例子：<br><code>&lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;访问菜鸟教程!&lt;/a&gt;</code></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_blank</td>
<td>在新窗口中打开被链接文档</td>
</tr>
<tr>
<td>_self</td>
<td>默认。在相同的框架中打开被链接文档</td>
</tr>
<tr>
<td>_parent</td>
<td>在父框架集中打开被链接文档</td>
</tr>
<tr>
<td>_top</td>
<td>在整个窗口中打开被链接文档</td>
</tr>
</tbody></table>
<h2 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h2><p>id属性可用于创建在一个HTML文档书签标记</p>
<p>书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的</p>
<p>用法：<br>在HTML文档中插入ID:<br><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></p>
<p>在HTML文档中创建一个链接到  有用的提示部分(id=”tips”）：<br><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p>
<p>或者，从另一个页面创建一个链接到  有用的提示部分(id=”tips”）：<br><code>&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p>
<h1 id="html引用"><a href="#html引用" class="headerlink" title="html引用"></a>html引用</h1><p><strong>短引用</strong>：<code>&lt;q&gt;aaaaaaa&lt;/q&gt;</code><br><strong>长引用</strong>：<code>&lt;blockquote&gt;aaaaaaaaaaaaaaaaaa&lt;/blockquote&gt;</code></p>
<p><strong>缩略词</strong>：对缩写进行标记能够为浏览器、翻译系统以及搜索引擎提供有用的信息<br><code>&lt;abbr title=&quot;World Health Organization&quot;&gt;WHO&lt;/abbr&gt;</code></p>
<p><strong>地址</strong>：用于联系信息的 HTML <code>&lt;address&gt;</code>，通常以斜体显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">Written by Donald Duck.<span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">Visit us at:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Example.com<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Box 564, Disneyland<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">USA</span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>著作标题</strong>：HTML <code>&lt;cite&gt;</code> 元素定义著作的标题。浏览器通常会以斜体显示 <code>&lt;cite&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">cite</span>&gt;</span>The Scream<span class="tag">&lt;/<span class="name">cite</span>&gt;</span> by Edward Munch. Painted in 1893.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>双向重写</strong>：<code>&lt;bdo&gt;</code> 元素用于覆盖当前文本方向</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>This text will be written from right to left<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html颜色"><a href="#html颜色" class="headerlink" title="html颜色"></a>html颜色</h1><p>只有少数颜色能直接用颜色名：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow</p>
<p>其他的颜色必须用#开始的16进制串</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 类</title>
    <url>/2021/04/02/html/html-%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="html-类"><a href="#html-类" class="headerlink" title="html 类"></a>html 类</h1><p>对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。<br>为相同的类设置相同的样式，或者为不同的类设置不同的样式。</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml">.cities &#123;  <span class="comment">&lt;!--类定义--&gt;</span></span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分类块级元素"><a href="#分类块级元素" class="headerlink" title="分类块级元素"></a>分类块级元素</h2><p>HTML <code>&lt;div&gt;</code> 元素是块级元素。它能够用作其他 HTML 元素的容器。</p>
<p>设置 <code>&lt;div&gt;</code> 元素的类，使我们能够为相同的 <code>&lt;div&gt;</code> 元素设置相同的类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.cities &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Paris<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paris is the capital and most populous city of France.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Tokyo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Tokyo is the capital of Japan, the center of the Greater Tokyo Area,</span><br><span class="line">and the most populous metropolitan area in the world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分类行内元素"><a href="#分类行内元素" class="headerlink" title="分类行内元素"></a>分类行内元素</h2><p>HTML <code>&lt;span&gt;</code> 元素是行内元素，能够用作文本的容器。</p>
<p>设置 <code>&lt;span&gt;</code> 元素的类，能够为相同的 <code>&lt;span&gt;</code> 元素设置相同的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span><span class="selector-class">.red</span> &#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Important<span class="tag">&lt;/<span class="name">span</span>&gt;</span> Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html类</tag>
      </tags>
  </entry>
  <entry>
    <title>html 简介</title>
    <url>/2021/04/01/html/html-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>HTML 是用来描述网页的一种语言。<br>HTML 不是一种编程语言，而是一种标记语言<br>HTML 使用标记标签来描述网页<br>HTML文档也叫做 web 页面</p>
<span id="more"></span>
<h1 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h2><p><code>&lt;!DOCTYPE html&gt;</code> 声明为 HTML5 文档<br><code>&lt;html&gt;</code> 元素是 HTML 页面的根元素<br><code>&lt;head&gt;</code> 元素包含了文档的元（meta）数据，如 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 定义网页编码格式为 utf-8。<br><code>&lt;title&gt;</code> 元素描述了文档的标题<br><code>&lt;body&gt;</code> 元素包含了可见的页面内容<br><code>&lt;h1&gt;</code> 元素定义一个大标题<br><code>&lt;p&gt;</code> 元素定义一个段落</p>
<h1 id="lt-DOCTYPE-gt-声明"><a href="#lt-DOCTYPE-gt-声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h1><p><code>&lt;!DOCTYPE&gt;</code>声明有助于浏览器中正确显示网页。<br>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。<br>doctype声明是不区分大小写的，以下方式均可<br><strong>html5</strong>的通用声明：<code>&lt;!DOCTYPE html&gt;</code></p>
<h1 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h1><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 <strong>UTF-8</strong> 或 <strong>GBK</strong>。<br>在<code>&lt;head&gt;</code>下一行声明<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础4</title>
    <url>/2021/04/02/html/html-%E5%9F%BA%E7%A1%804/</url>
    <content><![CDATA[<h1 id="html-id属性"><a href="#html-id属性" class="headerlink" title="html id属性"></a>html id属性</h1><p>HTML id 属性用于 为HTML 元素指定唯一的 id。<br>一个 HTML文档中不能存在多个有相同 id 的元素。</p>
<span id="more"></span>
<h2 id="使用id属性"><a href="#使用id属性" class="headerlink" title="使用id属性"></a>使用id属性</h2><p>id 属性用于指向样式表中的特定样式声明。JavaScript 也可使用它来访问和操作拥有特定 ID 的元素。</p>
<p>id 的<strong>语法</strong>是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。</p>
<p>下面的例子中有一个 <code>&lt;h1&gt;</code> 元素，它指向 id 名称 “myHeader”。这个 <code>&lt;h1&gt;</code> 元素将根据 head 部分中的 #myHeader 样式定义进行样式设置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#myHeader &#123;</span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">  <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;myHeader&quot;</span>&gt;</span>My Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="与class的差异"><a href="#与class的差异" class="headerlink" title="与class的差异"></a>与class的差异</h2><p>同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用</p>
<h2 id="通过-ID-和链接实现-HTML-书签"><a href="#通过-ID-和链接实现-HTML-书签" class="headerlink" title="通过 ID 和链接实现 HTML 书签"></a>通过 ID 和链接实现 HTML 书签</h2><p>HTML 书签用于<strong>让读者跳转至网页的特定部分</strong>。</p>
<p>要使用书签，您必须首先创建它，然后为它添加链接。</p>
<p>然后，当单击链接时，页面将滚动到带有书签的位置。</p>
<p>实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//创建书签</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">//然后，在同一张页面中，向这个书签添加一个链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">//或者，在另一张页面中，添加指向这个书签的链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;html_demo.html#C4&quot;</span>&gt;</span>Jump to Chapter 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在-JavaScript-中使用-id-属性"><a href="#在-JavaScript-中使用-id-属性" class="headerlink" title="在 JavaScript 中使用 id 属性"></a>在 JavaScript 中使用 id 属性</h2><p>JavaScript 也可以使用 id 属性为特定元素执行某些任务。</p>
<p>JavaScript 可以使用 getElementById() 方法访问拥有特定 id 的元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">displayResult</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;myHeader&quot;</span>).innerHTML = <span class="string">&quot;Have a nice day!&quot;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html-内联框架"><a href="#html-内联框架" class="headerlink" title="html 内联框架"></a>html 内联框架</h1><p>iframe 用于<strong>在网页内显示网页</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> <span class="comment">&lt;!--URL 指向隔离页面的位置--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Iframe-设置高度和宽度"><a href="#Iframe-设置高度和宽度" class="headerlink" title="Iframe 设置高度和宽度"></a>Iframe 设置高度和宽度</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性值的默认单位是像素，但也可以用<strong>百分比</strong>来设定（比如 “80%”）</p>
<h2 id="Iframe-删除边框"><a href="#Iframe-删除边框" class="headerlink" title="Iframe 删除边框"></a>Iframe 删除边框</h2><p>frameborder 属性规定是否显示 iframe 周围的边框,设置属性值为 “0” 就可以移除边框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-iframe-作为链接的目标"><a href="#使用-iframe-作为链接的目标" class="headerlink" title="使用 iframe 作为链接的目标"></a>使用 iframe 作为链接的目标</h2><p>iframe 可用作链接的目标（target）。</p>
<p>链接的 target 属性必须引用 iframe 的 name 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>W3School.com.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="html-javascript"><a href="#html-javascript" class="headerlink" title="html javascript"></a>html javascript</h1><p>HTML <code>&lt;script&gt;</code> 标签用于定义客户端脚本（JavaScript）。</p>
<p><code>&lt;script&gt;</code> 元素即可包含脚本语句，也可通过 src 属性指向外部脚本文件。</p>
<p>JavaScript 的常见用途是图像处理、表单验证和内容的动态更改。</p>
<p>HTML <code>&lt;noscript&gt;</code> 标签定义了替代内容，这些内容将显示给在浏览器中禁用了脚本或浏览器不支持脚本的用户</p>
<h1 id="html-文件路径"><a href="#html-文件路径" class="headerlink" title="html 文件路径"></a>html 文件路径</h1><table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;img src=&quot;picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于与当前网页相同的文件夹</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;images/picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于当前文件夹的 images 文件夹中</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;/images/picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 当前站点根目录的 images 文件夹中</td>
</tr>
<tr>
<td><code>&lt;img src=&quot;../picture.jpg&quot;&gt;</code></td>
<td>picture.jpg 位于当前文件夹的上一级文件夹中</td>
</tr>
</tbody></table>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径描述了网站文件夹结构中某个文件的位置。</p>
<p>文件路径会在链接外部文件时被用到：网页、图像、样式表、JavaScript</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>给出完整的文件路径，比如src=”<a href="https://www.w3school.com.cn/images/picture.jpg&quot;">https://www.w3school.com.cn/images/picture.jpg&quot;</a></p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>见表格</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Webpack</title>
    <url>/2021/04/26/vue_js/Vue-Webpack/</url>
    <content><![CDATA[<h1 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h1><p>webpack是一个现代的JavaScript应用的静态模块打包工具，它将许多文件（包括不能直接部署的less、cass等）转换并打包成一个文件夹，部署时直接用这个文件夹</p>
<p><strong>打包</strong>：将webpack中的各种<strong>资源模块进行打包合并</strong>成一个或多个包(Bundle)。并且在打包的过程中，还可以对<strong>资源进行处理</strong>，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</p>
<span id="more"></span>

<p><strong>模块</strong>：之前提到了模块标准CommonJs、AMD、CMD等，这些标准的代码不能直接被浏览器读取，<strong>打包工具</strong>能把这些转换为浏览器能理解的代码</p>
<h1 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h1><h2 id="node-js环境"><a href="#node-js环境" class="headerlink" title="node.js环境"></a>node.js环境</h2><p>webpack的运行需要node环境。node环境为了可以正确执行很多代码，需要依赖很多包。如果手动管理这些包就会很麻烦，因而node有一个自动的包管理工具<strong>npm</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装：<code>npm install webpack@3.6.0 -g</code><br>局部安装：<br><code>cd 目录 npm install webpack@3.6.0 --save-dev</code></p>
<p>为什么全局安装后，还<strong>需要局部安装</strong>呢？</p>
<ol>
<li>在终端直接执行webpack命令，使用的全局安装的webpack</li>
<li>当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</li>
</ol>
<h1 id="webpack基本使用"><a href="#webpack基本使用" class="headerlink" title="webpack基本使用"></a>webpack基本使用</h1><p>有以下三个js文件，mathUtil定义了数学函数，info定义了信息，main要使用前面两个js文件的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mathUtil.js 使用commonJs导出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abstract</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1-num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    add,</span><br><span class="line">    abstract</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//info.js 使用es6导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name=<span class="string">&quot;ywy144&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age=<span class="number">21</span>;</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line">  <span class="comment">//commonJs</span></span><br><span class="line"><span class="keyword">const</span> &#123;add,abstract&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtil.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>,<span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(abstract(<span class="number">30</span>,<span class="number">20</span>));</span><br><span class="line">  <span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info.name);</span><br><span class="line"><span class="built_in">console</span>.log(info.age);</span><br></pre></td></tr></table></figure>
<p>webpack打包文件的时候，如果发现一个文件<strong>导入了另一个文件</strong>。就会把另一个文件<strong>一起打包</strong>，打包到一个新文件中，然后html文件用新文件就可以了</p>
<p>打包之前要<strong>切换到源文件的目录</strong>：<code>cd 目录</code><br><strong>打包命令</strong>：<code>webpack 源文件地址 新文件地址</code><br>地址可以是相对地址，也可以是绝对地址</p>
<p>比如这里要把main.js打包到<code>./dist/bundle.js</code>中，命令即：<br><code>webpack ./src/main.js ./dist/bundle.js</code><br>这样main、mathUtil、info都打包到bundle里了，html直接在script里用bundle就行了<br>（<strong>命令行里用↑可以复制黏贴上一条命令</strong>）</p>
<h1 id="webpack-config-js和package-json"><a href="#webpack-config-js和package-json" class="headerlink" title="webpack.config.js和package.json"></a>webpack.config.js和package.json</h1><p>切换到上一级目录：<code>cd ..</code></p>
<p>现在有一个需求，命令里只敲一个webpack，就能自动把src文件夹里的main.js自动打包到dist文件夹里的bundle.js</p>
<p>先新建一个文件叫<code>webpack.config.js</code>，里面写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">//环境变量path,node的核心模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>), <span class="comment">//目标文件在的文件夹</span></span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span> <span class="comment">//目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output里的path最好动态获取，这样环境改变就不用重新改了</p>
<p>这样就需要在第一行写<code>const path=require(&#39;path&#39;)</code>,括号里面的path需要依赖node包，因而需要建立一个json文件</p>
<p>因而在命令里执行<code>npm init</code>，输入package name后一路回车，然后会生成一个叫package.json的文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;meetwebpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后括号里的path就会自己去找了</p>
<p>output里的path：<code>path: path.resolve(__dirname,&#39;dist&#39;)</code><br>path是一个对象，有一个resolve函数，用于拼接两个字符串<br>__direname是node里的一个全局变量，用于获取当前文件夹的地址，<code>&#39;dist&#39;</code>即当前文件夹下的一个子文件夹（也是目的文件所在的文件夹）</p>
<p><strong>这样就配置完了，命令里只输入一个webpack就可以自动打包了</strong></p>
<h2 id="webpack命令映射到npm命令"><a href="#webpack命令映射到npm命令" class="headerlink" title="webpack命令映射到npm命令"></a>webpack命令映射到npm命令</h2><p>有时候webpack命令很长（多个命令连起来写），这样我们就需要把webpack打包命令映射到npm命令里</p>
<p>进入package.json，找到script，添加build属性：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>这样输入npm run build之后，就会进入这个package.json里来找build对应的命令（即冒号后面的字符串）</p>
<p>但是有一点点区别，npm run会优先找本地的命令（局部webpack），然后再去找全局webpack（上面的例子用的是全局webpack）</p>
<h1 id="局部webpack"><a href="#局部webpack" class="headerlink" title="局部webpack"></a>局部webpack</h1><p>比如公司开发，你本地安装了webpack4.1.1，而公司已有的项目用的是webpack3.6.0，直接执行webpack，配置就会出问题</p>
<p>因而需要在项目里安装一个局部webpack：<code>npm install webpack@3.6.0 --save-dev</code><br>-dev表示<strong>开发时依赖</strong>（对应的还有运行时依赖）</p>
<p>安装完了之后文件夹里会多了个node_module文件夹。再进入package.json，发现多了点东西：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.6.0&quot;</span><br></pre></td></tr></table></figure>
<p>devDependencies表示开发时依赖这个版本的webpack</p>
<p>此时在命令行里输入webpack（或者映射的npm，因为build：webpack只在全局有，局部找不到），默认的还是全局webpack</p>
<h1 id="webpack中的css配置"><a href="#webpack中的css配置" class="headerlink" title="webpack中的css配置"></a>webpack中的css配置</h1><p>webpack的基本职责是处理js代码和js文件的依赖</p>
<p>css、png、less、ts等文件的处理，webpack自身是不支持的，需要扩展对应的loader</p>
<p>有时候css文件很多，一个个引用不合适，这时候就需要把所有css打包成一个模块</p>
<p>假设现在有一个normal.css文件，按照上面的方式打包不会带上这个css，因为main.js不依赖这个css。所以要在main.js加一行代码依赖这个css：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.js&#x27;</span>) <span class="comment">//括号里是css文件的地址</span></span><br></pre></td></tr></table></figure>
<p>然后安装css-loader：<code>npm install --save-dev css-loader@2.0.2</code><br>css-loader的用途是加载 CSS 文件并解析 import 的 CSS 文件，最终返回 CSS 代码</p>
<p>再去webpack.config.js中增加一个module属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        <span class="comment">//rule是一个数组，存储多个配置，test表示文件后缀名，use表示对文件使用什么loader</span></span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再安装style-loader：<code>npm install --save-dev style-loader</code><br>style-loader的用途是将模块导出的内容作为样式并添加到 DOM 中</p>
<h1 id="webpack中的less配置"><a href="#webpack中的less配置" class="headerlink" title="webpack中的less配置"></a>webpack中的less配置</h1><p>如果我们希望在项目中使用less、scss、stylus来写样式，那么需要安装对应的loader（其他的都一样）</p>
<p>安装：<code>npm install --save-dev less-loader less</code><br>（这里还安装了less）</p>
<p>再进入webpack.config.js，添加一个rules选项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;,<span class="comment">//上面的是之前弄得css-loader和style-loader</span></span><br><span class="line">          <span class="comment">//下面的use里也可以用字符串数组（和处理.css一样的方式）</span></span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.less/</span>,</span><br><span class="line">            use:[&#123;</span><br><span class="line">              loader: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">              loader: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">              loader: <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<h1 id="webpack的图片配置"><a href="#webpack的图片配置" class="headerlink" title="webpack的图片配置"></a>webpack的图片配置</h1><p>图片也会被打包，并重新命名（hash命名，防止重复）<br>图片打包后也会放到目标文件夹里，但这时候css里的background的url不是打包后的地址</p>
<ol>
<li>把index一起打包</li>
<li>在webpack.config.js中的output里增加：<code>publicPath: &#39;../dist/&#39;</code>,dist是打包的目标文件夹<h2 id="小于limit的图片"><a href="#小于limit的图片" class="headerlink" title="小于limit的图片"></a>小于limit的图片</h2>在normal.css中注释掉background-color，增加：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/p2.jpg&quot;</span>);</span><br></pre></td></tr></table></figure>
因而要安装url-loader：<code>npm install url-loader@1.1.2 --save-dev</code></li>
</ol>
<p>url-loader 功能类似于 file-loader, 但是在文件大小（单位为字节）低于指定的限制时，可以返回一个 DataURL</p>
<p>配置webpack.config.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>
<p>再次打包，就成功了</p>
<p><strong>limit属性</strong>的作用：当图片小于limit的数值（B）时，对图片进行base64编码</p>
<h2 id="大于limit的图片"><a href="#大于limit的图片" class="headerlink" title="大于limit的图片"></a>大于limit的图片</h2><p>这时候需要安装file-loader：<code>npm install --save-dev file-loader@3.0.1</code><br>增加配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="图片文件修改"><a href="#图片文件修改" class="headerlink" title="图片文件修改"></a>图片文件修改</h2><p>webpack自动帮助我们生成一个非常长的名字</p>
<ol>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</li>
</ol>
<p>所以，我们可以在options中添加上如下选项：</p>
<ol>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名<br>即修改webpack.config.js中rule里的url-loader，option里增加一个name：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">           limit: <span class="number">8192</span>,</span><br><span class="line">           <span class="comment">//img表示图片存到img文件夹，文件夹可以写多层</span></span><br><span class="line">           <span class="comment">//[name]表示用图片原来的名字</span></span><br><span class="line">           <span class="comment">//.表示字符串连接</span></span><br><span class="line">           <span class="comment">//[hash:8]表示只需要用8位哈希，用于避免命名冲突</span></span><br><span class="line">           <span class="comment">//[ext]表示用原来的扩展名</span></span><br><span class="line">           name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确<br>默认情况下，webpack会将生成的路径直接返回给使用者<br>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个<code>../dist/</code>（就是本节最开始改的）</p>
<h1 id="ES6语法转为ES5"><a href="#ES6语法转为ES5" class="headerlink" title="ES6语法转为ES5"></a>ES6语法转为ES5</h1><p>一些对ES6还不支持的浏览器没有办法很好的运行我们的代码</p>
<p>如果希望将ES6的语法转成ES5，那么就需要使用babel。</p>
<p>安装：<code>npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 </code></p>
<p>配置webpack.config.js文件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>exclude表示这些文件夹里的东西不会被转换</p>
<p>babel-loader速度很慢，并且会使得代码体积变大</p>
<h1 id="webpack配置Vue"><a href="#webpack配置Vue" class="headerlink" title="webpack配置Vue"></a>webpack配置Vue</h1><p>以前使用script标签引用Vue代码，不符合模块化</p>
<p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件</p>
<p>安装：<code>npm install vue --save</code><br>之后Vue就安装到这个文件夹里了，要用Vue的文件里加一句<code>import Vue from &#39;vue&#39;</code>就可以像之前那样用Vue了<br>注意：import没有写路径，就会自己去node_modules文件夹里找</p>
<p>直接打包后运行会报错：使用runtime-only版本的vue<br>Vue在打包的时候会生成两个版本，runtime-only和runtime-compiler，其中runtime-only要求代码里不允许有template（直接挂在Vue实例的div也看做是template），因而直接打包会出错</p>
<p>这时候在webpack.config.js里加一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span> <span class="comment">//es module</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>打包后会发布一堆代码版本，这个配置就指定了vue.esm.js包含runtime-compiler</p>
<h1 id="el和template的区别"><a href="#el和template的区别" class="headerlink" title="el和template的区别"></a>el和template的区别</h1><p>正常运行之后，我们来考虑另外一个问题：</p>
<ol>
<li>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</li>
<li>如果我们后面自定义了组件，也必须修改index.html来使用组件</li>
<li>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？</li>
</ol>
<p>定义template属性：</p>
<ol>
<li>在前面的Vue实例中，我们定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容</li>
<li>这里，我们可以将div元素中的内容删掉，只保留一个基本的id为div的元素</li>
<li>但是如果我依然希望在其中显示的内容，应该怎么处理呢？</li>
<li>我们可以再定义一个template属性，代码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;ywy144&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
这样以后修改div里的东西，就不用像以前那样直接修改html文件，可以直接去修改包含了Vue实例的文件</li>
</ol>
<p>el和template模板的关系是什么呢？</p>
<ol>
<li>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。</li>
<li>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。(包括<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>)</li>
</ol>
<p>书写template模块非常麻烦怎么办呢？</p>
<ol>
<li>没有关系，稍后我们会将template模板中的内容进行抽离。</li>
<li>会分成三部分书写：template、script、style，结构变得非常清晰。</li>
</ol>
<h2 id="剥离Vue实例中的template"><a href="#剥离Vue实例中的template" class="headerlink" title="剥离Vue实例中的template"></a>剥离Vue实例中的template</h2><p>通过组件，把template剥离出去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App=&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message: <span class="string">&#x27;ywy144&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;Vue nb&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    template: <span class="string">&#x27;&lt;App&gt;&lt;/App&gt;&#x27;</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>套娃，Vue实例里的template:<code>&lt;App&gt;&lt;/App&gt;</code>会被替换为组件App里的template，然后html里的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>会被替换为Vue实例的template</p>
<p><strong>还可以进一步</strong>减少main.js里的代码：把组件App的内容剥离到另一个js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src下建立一个vue文件夹，新建一个app.js</span></span><br><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message: <span class="string">&#x27;ywy144&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;Vue nb&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，把原来main.js里的App组件的内容改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/app&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>还能进一步剥离</strong>：app.js里的js代码和template还能再剥离</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在vue文件夹新建vue components文件app.vue--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--app.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;ywy144&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;Vue nb&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">  .title&#123;</span><br><span class="line"><span class="css">    <span class="attribute">font-family</span>: 华文行楷;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: aqua;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新建的app.vue已经打好框架了，把对应内容填进去就可以了<br>然后修改main.js：<code>import App from &#39;./vue/app.vue</code></p>
<p>这时候直接run会报错，因为缺了个处理.vue文件的loader：<br><code>npm install vue-loader@13.0.0 vue-template-compiler --save-dev</code><br>webpack.config.js配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="webpack-plugin"><a href="#webpack-plugin" class="headerlink" title="webpack plugin"></a>webpack plugin</h1><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<p><strong>loader和plugin区别</strong>：</p>
<ol>
<li>loader主要用于转换某些类型的模块，它是一个<strong>转换器</strong>（<strong>加载器</strong>）。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个<strong>扩展器</strong>。</li>
</ol>
<p>plugin的<strong>使用过程</strong>：</p>
<ol>
<li>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li>
<li>步骤二：在webpack.config.js中的plugins中配置插件。</li>
</ol>
<h2 id="添加版权的plugin"><a href="#添加版权的plugin" class="headerlink" title="添加版权的plugin"></a>添加版权的plugin</h2><p>为打包的文件添加版权声明。该插件名字叫BannerPlugin，属于webpack自带的插件</p>
<p><strong>修改</strong>webpack.config.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack=<span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="comment">//以下的plugins和modules、resolve等并列</span></span><br><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归ywy144所有&#x27;</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>再次打包，bundle.js最开始就会增加一句<code>/*! 最终版权归ywy144所有 */</code></p>
<h2 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h2><p>在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。</p>
<p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件</p>
<p>HtmlWebpackPlugin插件可以为我们做这些事情：</p>
<ol>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ol>
<p>安装HtmlWebpackPlugin插件:<code>npm install html-webpack-plugin@3.2.0 --save-dev </code></p>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<ol>
<li>这里的template表示根据什么模板来生成index.html</li>
<li>另外，我们需要删除之前在output中添加的publicPath属性</li>
<li>否则插入的script标签中的src可能会有问题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin=<span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="js压缩的plugin"><a href="#js压缩的plugin" class="headerlink" title="js压缩的plugin"></a>js压缩的plugin</h2><p>第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致<br><code>npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</code></p>
<p>修改配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uglifyJsPlugin=<span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> uglifyJsPlugin()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 浏览器1</title>
    <url>/2021/04/08/javascript/Javascript-%E6%B5%8F%E8%A7%88%E5%99%A81/</url>
    <content><![CDATA[<h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<span id="more"></span>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window对象不但充当全局作用域，而且表示浏览器窗口。</p>
<p>window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p>
<p>对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。</p>
<h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p>navigator对象表示浏览器的信息，最常用的属性包括：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>navigator.appName</td>
<td>浏览器名称</td>
</tr>
<tr>
<td>navigator.appVersion</td>
<td>浏览器版本</td>
</tr>
<tr>
<td>navigator.language</td>
<td>浏览器设置的语言</td>
</tr>
<tr>
<td>navigator.platform</td>
<td>操作系统类型</td>
</tr>
<tr>
<td>navigator.userAgent</td>
<td>浏览器设定的User-Agent字符串</td>
</tr>
</tbody></table>
<p>请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。</p>
<p>正确地判断浏览器信息的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表达式a &amp;&amp; 表达式b :  计算表达式a（也可以是函数）的运算结果，</span></span><br><span class="line"><span class="comment">                      如果为 True, 执行表达式b（或函数），并返回b的结果；</span></span><br><span class="line"><span class="comment">                      如果为 False，返回a的结果；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">表达式a || 表达式b :   计算表达式a（也可以是函数）的运算结果，</span></span><br><span class="line"><span class="comment">                      如果为 Fasle, 执行表达式b（或函数），并返回b的结果；</span></span><br><span class="line"><span class="comment">                      如果为 True，返回a的结果；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>screen对象表示屏幕的信息，常用的属性有：</p>
<p>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。</p>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>location对象表示当前页面的URL信息</p>
<p>一个<strong>完整的URL</strong>以用location.href获取。要获得URL各个部分的值，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.protocol; <span class="comment">// &#x27;http&#x27;</span></span><br><span class="line">location.host; <span class="comment">// &#x27;www.example.com&#x27;</span></span><br><span class="line">location.port; <span class="comment">// &#x27;8080&#x27;</span></span><br><span class="line">location.pathname; <span class="comment">// &#x27;/path/index.html&#x27;</span></span><br><span class="line">location.search; <span class="comment">// &#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.hash; <span class="comment">// &#x27;TOP&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要<strong>加载一个新页面</strong>，可以调用location.assign()。如果要<strong>重新加载当前页面</strong>，调用location.reload()方法非常方便。</p>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p>
<p>document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;努力学习JavaScript!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html数据</span></span><br><span class="line">&lt;dl id=<span class="string">&quot;drink-menu&quot;</span> style=<span class="string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span><br><span class="line">    &lt;dt&gt;摩卡&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;热摩卡咖啡&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;酸奶&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;北京老酸奶&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;果汁&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;鲜榨苹果汁&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<p>用document对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点(Array)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;drink-menu&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> drinks = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;dt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i, s;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;提供的饮料有:&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;drinks.length; i++) &#123;</span><br><span class="line">    s = s + drinks[i].innerHTML + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//提供的饮料有:摩卡,酸奶,果汁,</span></span><br></pre></td></tr></table></figure>
<p>document对象还有一个cookie属性，可以获取当前页面的Cookie。</p>
<p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p>
<p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p>
<p>JavaScript可以通过document.cookie读取到当前页面的Cookie：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>history对象保存了浏览器的历史记录，JavaScript可以调用history对象的<code>back()</code>或<code>forward()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。</p>
<p><strong>任何情况，你都不应该使用history这个对象了。</strong></p>
<h1 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h1><p>DOM是文档对象模型</p>
<p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ol>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ol>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code>，以及CSS选择器<code>document.getElementsByClassName()</code>。</p>
<p><font color="red">注意</font>：<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>返回的是节点数组，精确选择其中的元素还要用下标；选择元素中的全部孩子则需要用.children方法（也是个数组）；选择children中的孩子可以用下标、<code>.firstElementChild</code>和<code>.lastElementChild</code></p>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-table&#x27;</span>).getElementsByTagName(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-div&#x27;</span>).getElementsByClassName(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#q1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h2><p>拿到一个DOM节点后，我们可以对它进行更新。</p>
<p>可以直接修改节点的文本，方法有两种：</p>
<p>一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure>
<p>第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，<strong>保证无法设置任何HTML标签</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">&#x27;#ff0000&#x27;</span>;</span><br><span class="line">p.style.fontSize = <span class="string">&#x27;20px&#x27;</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">&#x27;2em&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h2><p>如果这个DOM节点是<strong>空</strong>的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p>
<p>如果这个DOM节点<strong>不是空</strong>的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。</p>
<p>有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;js&quot;</span>&gt;JavaScript&lt;/p&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//把&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;添加到&lt;div id=&quot;list&quot;&gt;的最后一项：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure>
<p>因为我们插入的js节点<strong>已经存在于当前的文档树</strong>，因此这个节点首先会从原先的位置删除，再插入到新的位置。</p>
<p>更多的时候我们会<strong>从零创建一个新的节点</strong>，然后插入到指定位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.appendChild(haskell);</span><br></pre></td></tr></table></figure>
<p>动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<code>&lt;style&gt;</code>节点，然后把它添加到<code>&lt;head&gt;</code>节点的末尾，这样就动态地给文档添加了新的CSS定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">d.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">d.innerHTML = <span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>要把子节点插入到指定的位置,可以使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到referenceElement之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HTML结构</span></span><br><span class="line">&lt;div id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;java&quot;</span>&gt;Java&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;python&quot;</span>&gt;Python&lt;/p&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;scheme&quot;</span>&gt;Scheme&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//把Haskell插入到Python之前</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;python&#x27;</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">haskell.id = <span class="string">&#x27;haskell&#x27;</span>;</span><br><span class="line">haskell.innerText = <span class="string">&#x27;Haskell&#x27;</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure>
<p>可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    i, c,</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.children.length; i++) &#123;</span><br><span class="line">    c = list.children[i]; <span class="comment">// 拿到第i个子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h2><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
<h1 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h1><p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p>
<p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ol>
<li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ol>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用value获得对应的用户输入值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value; <span class="comment">// &#x27;用户输入的值&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方式可以应用于<strong>text、password、hidden以及select</strong>。但是，对于<strong>单选框和复选框</strong>，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;monday&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tuesday&#x27;</span>);</span><br><span class="line">mon.value; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">tue.value; <span class="comment">// &#x27;2&#x27;</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure>
<h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p>设置值和获取值类似，对于<strong>text、password、hidden以及select</strong>，直接设置value就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value = <span class="string">&#x27;test@example.com&#x27;</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure>
<p>对于<strong>单选框和复选框</strong>，设置checked为true或false即可。</p>
<h2 id="html5-控件"><a href="#html5-控件" class="headerlink" title="html5 控件"></a>html5 控件</h2><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;date&quot;</span> value=<span class="string">&quot;2021-04-08&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="date" value="2021-04-08">
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;datetime-local&quot;</span> value=<span class="string">&quot;2015-07-01T02:03:04&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="datetime-local" value="2021-04-08T18:45:04">
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;color&quot;</span> value=<span class="string">&quot;#ff0000&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<input type="color" value="#ff0000">

<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>方式一是通过<code>&lt;form&gt;</code>元素的submit()方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的click事件，在JavaScript代码中提交表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。</p>
<p>因此，第二种方式是响应<code>&lt;form&gt;</code>本身的onsubmit事件，在提交form时作修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5,可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;login-form&quot;</span> method=<span class="string">&quot;post&quot;</span> onsubmit=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;input-password&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;hidden&quot;</span> id=<span class="string">&quot;md5-password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">    &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-password&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span><br><span class="line">    <span class="comment">// 把用户输入的明文变为MD5:</span></span><br><span class="line">    md5_pwd.value = toMD5(input_pwd.value);</span><br><span class="line">    <span class="comment">// 继续下一步:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>html 表单</title>
    <url>/2021/04/03/html/html-%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="html表单"><a href="#html表单" class="headerlink" title="html表单"></a>html表单</h1><p>HTML 表单用于搜集不同类型的用户输入。</p>
<span id="more"></span>
<p><strong>form</strong> 元素定义 HTML 表单<br>HTML 表单包含表单元素。表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。</p>
<h1 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h1><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>accept-charset</td>
<td>规定用于表单提交的字符编码。</td>
</tr>
<tr>
<td>action</td>
<td>规定提交表单时将表单数据发送到何处。</td>
</tr>
<tr>
<td>autocomplete</td>
<td>规定表单是否应打开自动完成（填写）功能。</td>
</tr>
<tr>
<td>enctype</td>
<td>规定将表单数据提交到服务器时应如何编码（仅供 method=”post”）。</td>
</tr>
<tr>
<td>method</td>
<td>规定发送表单数据时要使用的 HTTP 方法。</td>
</tr>
<tr>
<td>name</td>
<td>规定表单名称。</td>
</tr>
<tr>
<td>novalidate</td>
<td>规定提交时不应验证表单。</td>
</tr>
<tr>
<td>rel</td>
<td>规定链接资源和当前文档之间的关系。</td>
</tr>
<tr>
<td>target</td>
<td>规定提交表单后在何处显示接收到的响应。</td>
</tr>
</tbody></table>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p><strong>如果省略 action 属性，则将 action 设置为当前页面</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交后，将表单数据发送到 &quot;action_page.php&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/action_page.php&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;fname&quot;</span>&gt;</span>First name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bill&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;lname&quot;</span>&gt;</span>Last name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Gates&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<form action="/action_page.php">
  <label for="fname">First name:</label><br>
  <input type="text" id="fname" name="fname" value="Bill"><br>
  <label for="lname">Last name:</label><br>
  <input type="text" id="lname" name="lname" value="Gates"><br><br>
  <input type="submit" value="Submit">
</form>

<h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>默认值为 _self，这意味着响应将在当前窗口中打开。</p>
<p>target的值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_blank</td>
<td>响应显示在新窗口或选项卡中。</td>
</tr>
<tr>
<td>_self</td>
<td>响应显示在当前窗口中。</td>
</tr>
<tr>
<td>_parent</td>
<td>响应显示在父框架中。</td>
</tr>
<tr>
<td>_top</td>
<td>响应显示在窗口的整个 body 中。</td>
</tr>
<tr>
<td>framename</td>
<td>响应显示在命名的 iframe 中。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交的结果将在新的浏览器标签中打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/action_page.php&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>method 属性指定提交表单数据时要使用的 HTTP 方法。</p>
<p>表单数据可以作为 URL 变量（使用 method=”get”）或作为 HTTP post 事务（使用 method=”post”）发送。</p>
<p>提交表单数据时，默认的 HTTP 方法是 GET。</p>
<h1 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h1><h2 id="input元素"><a href="#input元素" class="headerlink" title="input元素"></a>input元素</h2><h3 id="输入类型：text"><a href="#输入类型：text" class="headerlink" title="输入类型：text"></a>输入类型：text</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<form>
 First name:<br>
<input type="text" name="firstname">
<br>
 Last name:<br>
<input type="text" name="lastname">
</form> 

<h3 id="输入类型：password"><a href="#输入类型：password" class="headerlink" title="输入类型：password"></a>输入类型：password</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入类型：submit"><a href="#输入类型：submit" class="headerlink" title="输入类型：submit"></a>输入类型：submit</h3><p>input type=”submit” 定义提交表单数据至表单处理程序的按钮。</p>
<p><strong>表单处理程序</strong>通常是包含处理输入数据的脚本的服务器页面。</p>
<p>在表单的 action 属性中规定表单处理程序：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span></span><br><span class="line">First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mickey&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mouse&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="输入类型：radio"><a href="#输入类型：radio" class="headerlink" title="输入类型：radio"></a>输入类型：radio</h3><p>定义单选按钮</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<form>
<input type="radio" name="sex" value="male" checked>Male
<br>
<input type="radio" name="sex" value="female">Female
</form> 

<h3 id="输入类型：checkbox"><a href="#输入类型：checkbox" class="headerlink" title="输入类型：checkbox"></a>输入类型：checkbox</h3><p>定义复选框</p>
<h3 id="输入类型：buttom"><a href="#输入类型：buttom" class="headerlink" title="输入类型：buttom"></a>输入类型：buttom</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me!&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<input type="button" onclick="alert('Hello World!')" value="Click Me!">

<h3 id="输入类型：number"><a href="#输入类型：number" class="headerlink" title="输入类型：number"></a>输入类型：number</h3><p>用于应该包含数字值的输入字段，能够对数字做出限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  Quantity (between 1 and 5):</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;quantity&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<form>
  Quantity (between 1 and 5):
  <input type="number" name="quantity" min="1" max="5">
</form>

<h2 id="input属性"><a href="#input属性" class="headerlink" title="input属性"></a>input属性</h2><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>value 属性规定输入字段的初始值</p>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>属性规定输入字段为只读（不能修改）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"> First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<form action="">
 First name:<br>
<input type="text" name="firstname" value="John" readonly>
<br>
 Last name:<br>
<input type="text" name="lastname">
</form> 

<h3 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h3><p>disabled 属性规定输入字段是禁用的。</p>
<p>被禁用的元素是不可用和不可点击的。</p>
<p>被禁用的元素不会被提交。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size 属性规定输入字段的尺寸（以字符计）</p>
<h3 id="maxlength"><a href="#maxlength" class="headerlink" title="maxlength"></a>maxlength</h3><p>maxlength 属性规定输入字段允许的最大长度</p>
<h3 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h3><p>autocomplete 属性规定表单或输入字段是否应该自动完成。</p>
<p>当自动完成开启，浏览器会基于用户之前的输入值自动填写值。</p>
<h3 id="novalidate"><a href="#novalidate" class="headerlink" title="novalidate"></a>novalidate</h3><p>如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证</p>
<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>form 属性规定 <code>&lt;input&gt;</code> 元素所属的一个或多个表单<br>使得input元素可以在表单外</p>
<h2 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h2><p>定义下拉列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<select name="cars">
<option value="volvo">Volvo</option>
<option value="saab">Saab</option>
<option value="fiat">Fiat</option>
<option value="audi">Audi</option>
</select>

<h2 id="option元素"><a href="#option元素" class="headerlink" title="option元素"></a>option元素</h2><p>定义待选择的选项。</p>
<p>列表通常会把首个选项显示为被选选项</p>
<p>您能够通过添加 selected 属性来定义预定义选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span> <span class="attr">selected</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br></pre></td></tr></table></figure>
<option value="fiat" selected>Fiat</option>

<h2 id="textarea元素"><a href="#textarea元素" class="headerlink" title="textarea元素"></a>textarea元素</h2><p>定义多行输入字段（文本域）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<textarea name="message" rows="10" cols="30">
The cat was playing in the garden.
</textarea>

<h2 id="HTML5-datalist元素"><a href="#HTML5-datalist元素" class="headerlink" title="HTML5 datalist元素"></a>HTML5 datalist元素</h2><p>为 input 元素规定预定义选项列表。</p>
<p>用户会在他们输入数据时看到预定义选项的下拉列表。</p>
<p>input 元素的 list 属性必须引用 datalist 元素的 id 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Internet Explorer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chrome&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Safari&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<form action="action_page.php">
<input list="browsers">
<datalist id="browsers">
   <option value="Internet Explorer">
   <option value="Firefox">
   <option value="Chrome">
   <option value="Opera">
   <option value="Safari">
</datalist> 
</form>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>html表单</tag>
      </tags>
  </entry>
  <entry>
    <title>html 基础6</title>
    <url>/2021/04/03/html/html-%E5%9F%BA%E7%A1%806/</url>
    <content><![CDATA[<h1 id="HTML-计算机代码元素"><a href="#HTML-计算机代码元素" class="headerlink" title="HTML 计算机代码元素"></a>HTML 计算机代码元素</h1><p>HTML code 元素定义编程代码示例,不保留多余的空格和折行,如需解决该问题，必须在 pre 元素中包围代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Coding Example:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">var person = &#123;</span><br><span class="line">    firstName:&quot;Bill&quot;,</span><br><span class="line">    lastName:&quot;Gates&quot;,</span><br><span class="line">    age:50,</span><br><span class="line">    eyeColor:&quot;blue&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>HTML var 元素定义数学变量：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Einstein wrote:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">var</span>&gt;</span>E = m c<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Einstein wrote:</p>

<p><var>E = m c<sup>2</sup></var></p>

<h1 id="HTML5-语义元素"><a href="#HTML5-语义元素" class="headerlink" title="HTML5 语义元素"></a>HTML5 语义元素</h1><p>语义元素清楚地向浏览器和开发者描述其意义。</p>
<p>非语义元素的例子：div 和 span - 无法提供关于其内容的信息。</p>
<p>语义元素的例子：form、table 以及 img - 清晰地定义其内容。</p>
<p>HTML5 提供了定义页面不同部分的新语义元素：</p>
<p>article，aside，details，figcaption，figure，footer，header，main，mark，nav，section，summary，time</p>
<h1 id="HTML5-代码约定"><a href="#HTML5-代码约定" class="headerlink" title="HTML5 代码约定"></a>HTML5 代码约定</h1><ol>
<li>请使用正确的文档类型 <code>&lt;!DOCTYPE html&gt;</code></li>
<li>请使用小写元素名</li>
<li>关闭所有 HTML 元素</li>
<li>关闭空的 HTML 元素 <code>&lt;meta charset=&quot;utf-8&quot; /&gt; </code></li>
<li>使用小写属性名 <code>&lt;div class=&quot;menu&quot;&gt;</code></li>
<li>属性值加引号 <code>&lt;table class=&quot;table striped&quot;&gt;</code></li>
<li>请始终对图像使用 alt 属性,当图像无法显示时该属性很重要</li>
<li>请始终定义图像尺寸。这样做会减少闪烁，因为浏览器会在图像加载之前为图像预留空间。</li>
<li>精简空格 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;</code></li>
<li>避免长代码行</li>
<li>请勿毫无理由地增加空行。为了提高可读性，请增加空行来分隔大型或逻辑代码块。为了提高可读性，请增加两个空格的缩进。请勿使用 TAB。</li>
</ol>
<h1 id="HTML-字符实体"><a href="#HTML-字符实体" class="headerlink" title="HTML 字符实体"></a>HTML 字符实体</h1><p>HTML 中的预留字符必须被替换为字符实体<br>常用：<br>空格 <code>&amp;nbsp;</code>  双引号 <code>&amp;quot;</code>  单引号 <code>&amp;apos;</code><br>乘号 <code>&amp;times;</code> 除号 <code>&amp;divide;</code></p>
<h1 id="HTML-URL"><a href="#HTML-URL" class="headerlink" title="HTML URL"></a>HTML URL</h1><p>统一资源定位器（URL）用于定位万维网上的文档（或其他数据）<br>格式：<code>scheme://host.domain:port/path/filename</code><br>scheme - 定义因特网服务的类型。最常见的类型是 http<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网域名，比如 w3school.com.cn<br>:port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p>
<h1 id="HTML-框架"><a href="#HTML-框架" class="headerlink" title="HTML 框架"></a>HTML 框架</h1><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。</p>
<p>使用框架的坏处：开发人员必须同时跟踪更多的HTML文档；很难打印整张页面</p>
<p>框架结构标签（frameset）定义如何将窗口分割为框架,每个 frameset 定义了一系列行或列,rows/columns 的值规定了每行或每列占据屏幕的面积</p>
<p>Frame 标签定义了放置在每个框架中的 HTML 文档。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,75%&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_a.htm&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_b.htm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="HTML-背景"><a href="#HTML-背景" class="headerlink" title="HTML 背景"></a>HTML 背景</h1><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;rgb(0,0,0)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片背景"><a href="#图片背景" class="headerlink" title="图片背景"></a>图片背景</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;clouds.gif&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">background</span>=<span class="string">&quot;http://www.w3school.com.cn/clouds.gif&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
